# -*- coding: utf-8 -*-
"""stabilizertensorcircuit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GZHKcQ2jxqD0t3z5_8HAU_hpZf6QpvBQ
"""

!pip install tensorcircuit

!pip install stim~=1.12
!pip install numpy
!pip install scipy
import stim
print(stim.__version__)

# Commented out IPython magic to ensure Python compatibility.
# Clone the repository
!git clone https://github.com/tencent-quantum-lab/tensorcircuit.git

# Change the directory to the cloned repository
# %cd repository

import stim

# Create a TableauSimulator instance
simulator = stim.TableauSimulator()

# Apply gates to the simulator
simulator.h(0)  # Apply a Hadamard gate on qubit 0
simulator.cnot(0, 1)  # Apply a CNOT gate with control qubit 0 and target qubit 1
simulator.measure(2)  # Measure qubit 2

import stim
import numpy as np

# Define your circuit here
circuit = stim.TableauSimulator()
...

# Apply operations to the circuit
circuit.h(0)
circuit.cnot(0, 1)
circuit.measure(0)
circuit.do(stim.Circuit("""
    H 3
    CZ 1 3
"""))
...

# Create the tableau representation
tableau = circuit.current_inverse_tableau() ** -1
zs = [tableau.z_output(k) for k in range(len(tableau))]
zs = np.array(zs)

"""we start by importing the necessary libraries, including tensorcircuit and numpy.

we set the data type for the circuit (ctype and rtype) to be complex numbers (complex64). It also sets the backend for computation to be TensorFlow (K = tc.set_backend("tensorflow")), which implies that computations involving the circuit will be performed using TensorFlow.

define the number of qubits (n) and the number of layers in the circuit (nlayers). In this example, n is set to 6 and nlayers is set to 6 as well.

we create a create_stabilizer_circuit, takes the number of qubits (n) and the number of layers (nlayers) as input and returns a stabilizer circuit. Stabilizer circuits are a specific type of quantum circuit used in quantum error correction and quantum computing.

The create_stabilizer_circuit function is called with the specified number of qubits and layers, and it generates the stabilizer circuit according to a specific pattern:

It applies a Hadamard gate to each qubit.
It applies a controlled-NOT (CNOT) gate between every pair of adjacent qubits.
It applies an S gate (also known as the phase gate) to each qubit.
These operations are repeated for each layer of the circuit.
 the code prints the generated stabilizer circuit.
"""

import tensorcircuit as tc
import numpy as np

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a stabilizer circuit
def create_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
    return c

# Create the stabilizer circuit
circuit = create_stabilizer_circuit(n, nlayers)

# Print the circuit
print("Stabilizer Circuit:")
print(circuit)

"""Imports: The code imports necessary libraries: tensorcircuit for creating quantum circuits, numpy for numerical operations, and stim for quantum simulation.

Setting Data Type and Backend: It sets the data type for the circuit to be complex64 and the backend for computation to be TensorFlow.

Defining Circuit Parameters: It defines the number of qubits (n) and the number of layers in the circuit (nlayers).

Creating the Stabilizer Circuit: The create_stabilizer_circuit function is defined to create a stabilizer circuit. It iterates through each layer and applies Hadamard gates (H), CNOT gates (CNOT), and S gates (S) to each qubit.

Transforming to Stim Circuit: The tc_to_stim function converts the TensorCircuit to a Stim circuit. It maps the gates from TensorCircuit to Stim gates and appends mid-circuit measurement gates (M) if present.

Printing the Stim Circuit: It prints the generated Stim circuit.

Creating Stim TableauSimulator: It creates a Stim TableauSimulator for running the simulation.

Running the Stim Circuit: It iterates over the instructions in the Stim circuit and executes them using the Stim TableauSimulator.

Extracting the Stabilizer Tableau: It extracts the stabilizer tableau from the simulator after the circuit execution.

Computing Entanglement Entropy: The compute_entanglement_entropy function computes the entanglement entropy from the stabilizer tableau. It constructs a binary matrix representing the stabilizer tableau and computes the rank of the matrix to determine the entanglement entropy.

Printing the Entanglement Entropy: It prints the computed entanglement entropy.
"""

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a stabilizer circuit
def create_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
    return c

# Create the stabilizer circuit
circuit = create_stabilizer_circuit(n, nlayers)

# Function to transform TensorCircuit to Stim circuit
def tc_to_stim(tc_circuit):
    # Initialize Stim circuit
    stim_circuit = stim.Circuit()

    # Iterate over instructions in TensorCircuit
    for instruction in tc_circuit._qir:
        # Extract gate type and qubits
        gate_type = instruction["gate"]
        qubits = instruction.get("targets", [])  # Check for 'targets' key

        # Map TensorCircuit gate types to Stim gate types
        if gate_type == 'H':
            stim_circuit.append_operation("H", qubits)
        elif gate_type == 'CNOT':
            stim_circuit.append_operation("CX", qubits)
        elif gate_type == 'S':
            stim_circuit.append_operation("S", qubits)


    # Append mid-circuit measurement
    for measurement in tc_circuit._extra_qir:
        if measurement["gate"] == 'M':
            qubit = measurement["target"]
            # Stim mid-circuit measurement operation
            stim_circuit.append_operation("M", [qubit])

    return stim_circuit

# Transform TensorCircuit to Stim circuit
stim_circuit = tc_to_stim(circuit)

# Debugging: Print the Stim circuit
print("Stim Circuit:")
print(stim_circuit)

# Create a Stim TableauSimulator
simulator = stim.TableauSimulator()

# Run the Stim circuit
for instruction in stim_circuit:
    simulator.do(instruction)

# Extract the stabilizer tableau
stabilizer_tableau = simulator.current_inverse_tableau() ** -1

# Debugging: Print the stabilizer tableau to inspect its structure
print("Stabilizer Tableau:")
print(stabilizer_tableau)

# Function to compute the entanglement entropy
def compute_entanglement_entropy(stabilizer_tableau):
    # Get the number of rows in the stabilizer tableau
    num_rows = len(stabilizer_tableau)

    # Compute the number of qubits (assuming the tableau is square)
    num_qubits = num_rows // 2

    # Create an empty binary matrix
    binary_matrix = np.zeros((2 * num_qubits, 2 * num_qubits), dtype=int)

    # Populate the binary matrix
    for i in range(num_qubits):
        # Get the Z output for the ith qubit
        z_output = stabilizer_tableau.z_output(i)

        # Extract the stabilizer information for the ith qubit
        for j in range(num_qubits):
            if z_output[j]:
                # Set the corresponding entry in the binary matrix
                binary_matrix[i, j + num_qubits] = 1

        # Get the X output for the ith qubit
        x_output = stabilizer_tableau.x_output(i)

        # Extract the stabilizer information for the ith qubit
        for j in range(num_qubits):
            if x_output[j]:
                # Set the corresponding entry in the binary matrix
                binary_matrix[i + num_qubits, j] = 1

    # Check if the binary matrix is empty
    if np.count_nonzero(binary_matrix) == 0:
        return 0  # Return entropy of 0 for an empty matrix

    # Compute the rank of the binary matrix
    rank = np.linalg.matrix_rank(binary_matrix)

    # Compute the entanglement entropy
    entropy = num_qubits - rank

    return entropy

# Compute and print the entanglement entropy
try:
    entropy = compute_entanglement_entropy(stabilizer_tableau)
    print("Entanglement Entropy:", entropy)
except Exception as e:
    print("Error:", e)

print("Stabilizer Tableau:")
print(stabilizer_tableau)

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a modified stabilizer circuit with entanglement
def create_modified_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
        # Apply additional gates to introduce entanglement
        for i in range(n - 1):
            c.CNOT(i, (i + 2) % n)  # Add CNOT between neighboring qubits
        c.SWAP(0, n - 1)  # Swap the first and last qubits
    return c

# Create the modified stabilizer circuit
modified_circuit = create_modified_stabilizer_circuit(n, nlayers)

# Transform modified TensorCircuit to Stim circuit
modified_stim_circuit = tc_to_stim(modified_circuit)

# Debugging: Print the modified Stim circuit
print("Modified Stim Circuit:")
print(modified_stim_circuit)

# Create a Stim TableauSimulator for the modified circuit
modified_simulator = stim.TableauSimulator()

# Run the modified Stim circuit
for instruction in modified_stim_circuit:
    modified_simulator.do(instruction)

# Extract the modified stabilizer tableau
modified_stabilizer_tableau = modified_simulator.current_inverse_tableau() ** -1

# Debugging: Print the modified stabilizer tableau to inspect its structure
print("Modified Stabilizer Tableau:")
print(modified_stabilizer_tableau)

# Compute and print the modified entanglement entropy
modified_entropy = compute_entanglement_entropy(modified_stabilizer_tableau)
print("Modified Entanglement Entropy:", modified_entropy)

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a modified stabilizer circuit with increased entanglement
def create_modified_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
        # Apply additional gates to introduce more entanglement
        for i in range(n - 1):
            c.CNOT(i, (i + 2) % n)  # Add CNOT between neighboring qubits
        c.CNOT(0, n - 1)  # Add a CNOT between the first and last qubits to increase entanglement
    return c

# Create the modified stabilizer circuit
modified_circuit = create_modified_stabilizer_circuit(n, nlayers)

# Transform modified TensorCircuit to Stim circuit
modified_stim_circuit = tc_to_stim(modified_circuit)

# Debugging: Print the modified Stim circuit
print("Modified Stim Circuit:")
print(modified_stim_circuit)

# Create a Stim TableauSimulator for the modified circuit
modified_simulator = stim.TableauSimulator()

# Run the modified Stim circuit
for instruction in modified_stim_circuit:
    modified_simulator.do(instruction)

# Extract the modified stabilizer tableau
modified_stabilizer_tableau = modified_simulator.current_inverse_tableau() ** -1

# Debugging: Print the modified stabilizer tableau to inspect its structure
print("Modified Stabilizer Tableau:")
print(modified_stabilizer_tableau)

# Compute and print the modified entanglement entropy
modified_entropy = compute_entanglement_entropy(modified_stabilizer_tableau)
print("Modified Entanglement Entropy:", modified_entropy)

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a modified stabilizer circuit with increased entanglement
def create_modified_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
        # Apply additional gates to introduce more entanglement
        for i in range(n - 1):
            c.CNOT(i, (i + 2) % n)  # Add CNOT between neighboring qubits
        c.CNOT(0, n - 1)  # Add a CNOT between the first and last qubits to increase entanglement
        # Add more CNOT gates to increase entanglement further
        for i in range(n):
            c.CNOT(i, (i + 3) % n)  # Add CNOT between every third qubit
    return c

# Create the modified stabilizer circuit
modified_circuit = create_modified_stabilizer_circuit(n, nlayers)

# Transform modified TensorCircuit to Stim circuit
modified_stim_circuit = tc_to_stim(modified_circuit)

# Debugging: Print the modified Stim circuit
print("Modified Stim Circuit:")
print(modified_stim_circuit)

# Create a Stim TableauSimulator for the modified circuit
modified_simulator = stim.TableauSimulator()

# Run the modified Stim circuit
for instruction in modified_stim_circuit:
    modified_simulator.do(instruction)

# Extract the modified stabilizer tableau
modified_stabilizer_tableau = modified_simulator.current_inverse_tableau() ** -1

# Debugging: Print the modified stabilizer tableau to inspect its structure
print("Modified Stabilizer Tableau:")
print(modified_stabilizer_tableau)

# Compute and print the modified entanglement entropy
modified_entropy = compute_entanglement_entropy(modified_stabilizer_tableau)
print("Modified Entanglement Entropy:", modified_entropy)

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a modified stabilizer circuit with entanglement
def create_modified_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
        # Apply additional gates to introduce entanglement
        for i in range(n - 1):
            c.CNOT(i, (i + 2) % n)  # Add CNOT between neighboring qubits
        c.SWAP(0, n - 1)  # Swap the first and last qubits
    return c
def sample(self, shots=1, midcircuit_measurement=False):
    """
    Sample measurement results from the circuit.

    Args:
        shots (int): Number of measurement shots to perform.
        midcircuit_measurement (bool): Whether to perform mid-circuit measurements.

    Returns:
        list: List of measurement results, where each result is represented as a binary string.
    """
    # Perform circuit simulation and record measurement results
    measurement_results = []
    for _ in range(shots):
        # Run the circuit simulation
        result = self.simulate()
        # Record measurement results
        if midcircuit_measurement:
            midcircuit_result = result['midcircuit_measurement']
            measurement_results.append(midcircuit_result)
        else:
            final_result = result['final_measurement']
            measurement_results.append(final_result)
    return measurement_results
# Create the modified stabilizer circuit
modified_circuit = create_modified_stabilizer_circuit(n, nlayers)

# Transform modified TensorCircuit to Stim circuit
modified_stim_circuit = tc_to_stim(modified_circuit)

# Debugging: Print the modified Stim circuit
print("Modified Stim Circuit:")
print(modified_stim_circuit)

# Create a Stim TableauSimulator for the modified circuit
modified_simulator = stim.TableauSimulator()

# List to store mid-circuit measurement results
tc_measurement_results = []

# Run the modified Stim circuit
for instruction in modified_stim_circuit:
    # Execute the instruction
    modified_simulator.do(instruction)

    # Check for mid-circuit measurement
    for operation in instruction.operations:
        if operation.gate == "M":
            qubit = operation.target
            # Record the mid-circuit measurement result
            result = modified_simulator.measure(qubit)
            tc_measurement_results.append(result)

# Extract the modified stabilizer tableau
modified_stabilizer_tableau = modified_simulator.current_inverse_tableau() ** -1

# Debugging: Print the modified stabilizer tableau to inspect its structure
print("Modified Stabilizer Tableau:")
print(modified_stabilizer_tableau)

# Compute and print the modified entanglement entropy
modified_entropy = compute_entanglement_entropy(modified_stabilizer_tableau)
print("Modified Entanglement Entropy:", modified_entropy)

# Compute the entanglement entropy from TensorCircuit measurement results
if tc_measurement_results:
    tc_entropy = compute_entropy_from_tc_measurement(tc_measurement_results)
    print("Modified Entanglement Entropy (from TensorCircuit):", tc_entropy)

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a modified stabilizer circuit with increased entanglement
def create_modified_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
        # Apply additional gates to introduce more entanglement
        for i in range(n - 1):
            c.CNOT(i, (i + 2) % n)  # Add CNOT between neighboring qubits
        c.CNOT(0, n - 1)  # Add a CNOT between the first and last qubits to increase entanglement
        # Add more CNOT gates to increase entanglement further
        for i in range(n):
            c.CNOT(i, (i + 3) % n)  # Add CNOT between every third qubit
    return c

# Create the modified stabilizer circuit
modified_circuit = create_modified_stabilizer_circuit(n, nlayers)

# Transform modified TensorCircuit to Stim circuit
modified_stim_circuit = tc_to_stim(modified_circuit)

# Debugging: Print the modified Stim circuit
print("Modified Stim Circuit:")
print(modified_stim_circuit)

# Create a Stim TableauSimulator for the modified circuit
modified_simulator = stim.TableauSimulator()

# Run the modified Stim circuit
for instruction in modified_stim_circuit:
    modified_simulator.do(instruction)

# Extract the modified stabilizer tableau
modified_stabilizer_tableau = modified_simulator.current_inverse_tableau() ** -1

# Debugging: Print the modified stabilizer tableau to inspect its structure
print("Modified Stabilizer Tableau:")
print(modified_stabilizer_tableau)

# Compute and print the modified entanglement entropy
modified_entropy = compute_entanglement_entropy(modified_stabilizer_tableau)
print("Modified Entanglement Entropy:", modified_entropy)

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 6
nlayers = 6

# Function to create a modified stabilizer circuit with increased entanglement
def create_modified_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
        # Apply additional gates to introduce more entanglement
        for i in range(n - 1):
            c.CNOT(i, (i + 2) % n)  # Add CNOT between neighboring qubits
        c.CNOT(0, n - 1)  # Add a CNOT between the first and last qubits to increase entanglement
        # Add more CNOT gates to increase entanglement further
        for i in range(n):
            c.CNOT(i, (i + 3) % n)  # Add CNOT between every third qubit
    return c

# Function to transform TensorCircuit to Stim circuit
def tc_to_stim(tc_circuit):
    # Initialize Stim circuit
    stim_circuit = stim.Circuit()

    # Iterate over instructions in TensorCircuit
    for instruction in tc_circuit._qir:
        # Extract gate type and qubits
        gate_type = instruction["gate"]
        qubits = instruction.get("targets", [])  # Check for 'targets' key

        # Map TensorCircuit gate types to Stim gate types
        if gate_type == 'H':
            stim_circuit.append_operation("H", qubits)
        elif gate_type == 'CNOT':
            stim_circuit.append_operation("CX", qubits)
        elif gate_type == 'S':
            stim_circuit.append_operation("S", qubits)
        # Add more gate mappings as needed

    # Append mid-circuit measurement
    for measurement in tc_circuit._extra_qir:
        if measurement["gate"] == 'M':
            qubit = measurement["target"]
            # Stim mid-circuit measurement operation
            stim_circuit.append_operation("M", [qubit])

    return stim_circuit

# Function to compute the entanglement entropy
def compute_entanglement_entropy(measurement_results):
    if not measurement_results:
        return 0

    num_qubits = len(measurement_results[0])
    counts = {format(i, '0' + str(num_qubits) + 'b'): 0 for i in range(2 ** num_qubits)}
    for result in measurement_results:
        counts[result] += 1
    probabilities = np.array(list(counts.values())) / sum(counts.values())
    entropy = -np.sum(probabilities * np.log2(probabilities))
    return entropy

# Create the modified stabilizer circuit
modified_circuit = create_modified_stabilizer_circuit(n, nlayers)

# Transform modified TensorCircuit to Stim circuit
modified_stim_circuit = tc_to_stim(modified_circuit)

# Debugging: Print the modified Stim circuit
print("Modified Stim Circuit:")
print(modified_stim_circuit)

# Create a Stim TableauSimulator for the modified circuit
modified_simulator = stim.TableauSimulator()

# Run the modified Stim circuit with mid-circuit measurements
modified_measurement_results = []
for instruction in modified_stim_circuit:
    if instruction[0] == 'M':
        # Perform mid-circuit measurement
        qubit_index = instruction[1][0]  # Extract the qubit index from the measurement instruction
        measurement_result = modified_simulator.measure(qubit_index)
        modified_measurement_results.append(measurement_result)
    else:
        modified_simulator.do(instruction)

# Compute and print the modified entanglement entropy using the recorded measurement results
modified_entropy = compute_entanglement_entropy(modified_measurement_results)
print("Modified Entanglement Entropy:", modified_entropy)

import tensorcircuit as tc
import numpy as np
import stim

# Set the data type for the circuit
ctype, rtype = tc.set_dtype("complex64")
K = tc.set_backend("tensorflow")

# Define the number of qubits and the number of layers in the circuit
n = 50
nlayers = 6

# Function to create a modified stabilizer circuit with increased entanglement
def create_modified_stabilizer_circuit(n, nlayers):
    c = tc.Circuit(n)
    for _ in range(nlayers):
        # Apply Hadamard gate to all qubits
        for i in range(n):
            c.H(i)
        # Apply CNOT gate between every pair of qubits
        for i in range(n - 1):
            c.CNOT(i, i + 1)
        # Apply S gate to each qubit
        for i in range(n):
            c.S(i)
        # Apply additional gates to introduce more entanglement
        for i in range(n - 1):
            c.CNOT(i, (i + 2) % n)  # Add CNOT between neighboring qubits
        c.CNOT(0, n - 1)  # Add a CNOT between the first and last qubits to increase entanglement
        # Add more CNOT gates to increase entanglement further
        for i in range(n):
            c.CNOT(i, (i + 3) % n)  # Add CNOT between every third qubit
    return c

# Function to transform TensorCircuit to Stim circuit
def tc_to_stim(tc_circuit):
    # Initialize Stim circuit
    stim_circuit = stim.Circuit()

    # Iterate over instructions in TensorCircuit
    for instruction in tc_circuit._qir:
        # Extract gate type and qubits
        gate_type = instruction["gate"]
        qubits = instruction.get("targets", [])  # Check for 'targets' key

        # Map TensorCircuit gate types to Stim gate types
        if gate_type == 'H':
            stim_circuit.append_operation("H", qubits)
        elif gate_type == 'CNOT':
            stim_circuit.append_operation("CX", qubits)
        elif gate_type == 'S':
            stim_circuit.append_operation("S", qubits)
        # Add more gate mappings as needed

    # Append mid-circuit measurement
    for measurement in tc_circuit._extra_qir:
        if measurement["gate"] == 'M':
            qubit = measurement["target"]
            # Stim mid-circuit measurement operation
            stim_circuit.append_operation("M", [qubit])

    return stim_circuit

# Function to compute the entanglement entropy
def compute_entanglement_entropy(measurement_results):
    if not measurement_results:
        return 0

    num_qubits = len(measurement_results[0])
    counts = {format(i, '0' + str(num_qubits) + 'b'): 0 for i in range(2 ** num_qubits)}
    for result in measurement_results:
        counts[result] += 1
    probabilities = np.array(list(counts.values())) / sum(counts.values())
    entropy = -np.sum(probabilities * np.log2(probabilities))
    return entropy

# Create the modified stabilizer circuit
modified_circuit = create_modified_stabilizer_circuit(n, nlayers)

# Transform modified TensorCircuit to Stim circuit
modified_stim_circuit = tc_to_stim(modified_circuit)

# Debugging: Print the modified Stim circuit
print("Modified Stim Circuit:")
print(modified_stim_circuit)

# Create a Stim TableauSimulator for the modified circuit
modified_simulator = stim.TableauSimulator()

# Run the modified Stim circuit with mid-circuit measurements
modified_measurement_results = []
for instruction in modified_stim_circuit:
    if instruction[0] == 'M':
        # Perform mid-circuit measurement
        qubit_index = instruction[1][0]  # Extract the qubit index from the measurement instruction
        measurement_result = modified_simulator.measure(qubit_index)
        modified_measurement_results.append(measurement_result)
        print("Measurement result:", measurement_result)  # Debug print
    else:
        modified_simulator.do(instruction)

# Compute and print the modified entanglement entropy using the recorded measurement results
modified_entropy = compute_entanglement_entropy(modified_measurement_results)
print("Modified Entanglement Entropy:", modified_entropy)