# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The TensorCircuit Authors
# This file is distributed under the same license as the tensorcircuit
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tensorcircuit \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-15 10:02+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/modules.rst:2
msgid "tensorcircuit"
msgstr ""

#~ msgid "get the `tc.backend` object"
#~ msgstr ""

#~ msgid "Backend doesn't exist for `backend` argument"
#~ msgstr ""

#~ msgid "the `tc.backend` object that with all registered universal functions"
#~ msgstr ""

#~ msgid ""
#~ "call random normal function with the "
#~ "random state management behind the scene"
#~ msgstr ""

#~ msgid ""
#~ "a jax like split API, but does't"
#~ " split the key generator for other"
#~ " backends. just for a consistent "
#~ "interface of random code, be careful "
#~ "that you know what the function "
#~ "actually does."
#~ msgstr ""

#~ msgid "set random state attached in the backend"
#~ msgstr ""

#~ msgid "uniform random sampler for ``low`` to ``high``"
#~ msgstr ""

#~ msgid "compute expectation of corresponding operators"
#~ msgstr ""

#~ msgid "reference: arXiv:1201.3974."
#~ msgstr ""

#~ msgid "compute the output wavefunction from the circuit"
#~ msgstr ""

#~ msgid ""
#~ "[deprecated] direct manipulate on  "
#~ "``QuOperator`` is suggested compute "
#~ ":math:`\\langle bra\\vert ops \\vert "
#~ "ket\\rangle`"
#~ msgstr ""

#~ msgid ""
#~ "set runtime contractor of the "
#~ "tensornetwork for a better contraction "
#~ "path"
#~ msgstr ""

#~ msgid "valid for \"custom\" or \"custom_stateful\" as method, defaults to None"
#~ msgstr ""

#~ msgid ""
#~ "not very useful, as ``memory_limit`` "
#~ "leads to ``branch`` contraction instead "
#~ "of ``greedy`` which is rather slow, "
#~ "defaults to None"
#~ msgstr ""

#~ msgid "tensornetwork version is too low to support some of the contractors"
#~ msgstr ""

#~ msgid "unknown method options"
#~ msgstr ""

#~ msgid "set the runtime numerical dtype of tensors"
#~ msgstr ""

#~ msgid ""
#~ "\"complex64\" or \"complex128\", defaults to"
#~ " None, which is equivalent to "
#~ "\"complex64\""
#~ msgstr ""

#~ msgid "naive statevector simulator contraction path"
#~ msgstr ""

#~ msgid "list of ``tn.Node``"
#~ msgstr ""

#~ msgid "list of dangling node edges, defaults to None"
#~ msgstr ""

#~ msgid "``tn.Node`` after contraction"
#~ msgstr ""

#~ msgid "set the runtime backend of tensorcircuit"
#~ msgstr ""

#~ msgid ""
#~ "\"numpy\", \"tensorflow\", \"jax\", \"pytorch\". "
#~ "defaults to None, which gives the "
#~ "same behavior as "
#~ "``tensornetwork.backend_contextmanager.get_default_backend()``"
#~ msgstr ""

#~ msgid "Note one should provide the gate with properly reshaped"
#~ msgstr ""

#~ msgid "Returns a LaTeX bmatrix"
#~ msgstr ""

#~ msgid "$\\exp{-i    heta unitary}$"
#~ msgstr ""

#~ msgid ""
#~ "Returns the random single qubit gate "
#~ "described in https://arxiv.org/abs/2002.07730."
#~ msgstr ""

#~ msgid "e^{-        heta/2 i X}"
#~ msgstr ""

#~ msgid "e^{-        heta/2 i Y}"
#~ msgstr ""

#~ msgid "e^{-        heta/2 i Z}"
#~ msgstr ""

#~ msgid ""
#~ "`QuantumLayer` wraps the quantum function "
#~ "`f` as a `keras.Layer`, so that "
#~ "tensorcircuit is better integrated with "
#~ "tensorflow"
#~ msgstr ""

#~ msgid ""
#~ "Load function from the files in "
#~ "``tf.savedmodel`` format. We can load "
#~ "several functions at the same time, "
#~ "as they can be the same function"
#~ " of different input shapes."
#~ msgstr ""

#~ msgid "keras loss function that directly taking the model output at the loss"
#~ msgstr ""

#~ msgid "save tf function in file (``tf.savedmodel`` format)"
#~ msgstr ""

#~ msgid ""
#~ "mps = tc.MPSCircuit(3) mps.H(1) mps.CNOT(0,"
#~ " 1) mps.rx(2, theta=tc.num_to_tensor(1.)) "
#~ "mps.expectation_single_gate(tc.gates.z(), 2)"
#~ msgstr ""

#~ msgid "the center position of MPS, default to 0"
#~ msgstr ""

#~ msgid "qubit indices of the gate"
#~ msgstr ""

#~ msgid ""
#~ "Apply a double qubit gate on "
#~ "adjacent qubits of MPS, truncation rule"
#~ " is speficied by `set_truncation_rule`"
#~ msgstr ""

#~ msgid ""
#~ "Apply a double qubit gate on MPS,"
#~ " truncation rule is speficied by "
#~ "`set_truncation_rule` :param gate: gate to "
#~ "be applied :type gate: Gate :param "
#~ "index1: first qubit index of the "
#~ "gate :type index1: int :param index2:"
#~ " second qubit index of the gate "
#~ ":type index2: int"
#~ msgstr ""

#~ msgid ""
#~ "Apply a single qubit gate on MPS,"
#~ " the gate must be unitary, no "
#~ "truncation is needed :param gate: gate"
#~ " to be applied :type gate: Gate "
#~ ":param index: qubit indices of the "
#~ "gate :type index: int"
#~ msgstr ""

#~ msgid "Get the conjugate of the current MPS"
#~ msgstr ""

#~ msgid "Copy the current MPS"
#~ msgstr ""

#~ msgid "Copy the current MPS without the tensors"
#~ msgstr ""

#~ msgid "Compute expectation of the corresponding single qubit gate"
#~ msgstr ""

#~ msgid "Compute correlation of the corresponding two gates"
#~ msgstr ""

#~ msgid "first gate to be applied"
#~ msgstr ""

#~ msgid "second gate to be applied"
#~ msgstr ""

#~ msgid "qubit index of the first gate"
#~ msgstr ""

#~ msgid "qubit index of the second gate"
#~ msgstr ""

#~ msgid "Construct the MPS from a given wavefunction"
#~ msgstr ""

#~ msgid ""
#~ "operator and its position on the "
#~ "circuit, eg. ``(gates.Z(), [1]), (gates.X(),"
#~ " [2])`` is for operator :math:`Z_1X_2`"
#~ msgstr ""

#~ msgid "check whether the circuit is legal"
#~ msgstr ""

#~ msgid ""
#~ "Wrapper of tn.FiniteMPS.position Set "
#~ "orthogonality center :param site: "
#~ "orthogonality center :type site: int"
#~ msgstr ""

#~ msgid "compute the projection between `other` as bra and `self` as ket"
#~ msgstr ""

#~ msgid ""
#~ "Set truncation rules when double qubit"
#~ " gates are applied. If nothing is "
#~ "specified, no truncation will take place"
#~ " and the bond dimension will keep "
#~ "growing. For more details, refer to "
#~ "`split_tensor`"
#~ msgstr ""

#~ msgid ""
#~ "Split the tensor by SVD or QR "
#~ "depends on whether a truncation is "
#~ "required"
#~ msgstr ""

#~ msgid "two tensors after splitting"
#~ msgstr ""

#~ msgid ""
#~ "Constructs a new `QuAdjointVector` from "
#~ "a tensor network. This encapsulates an"
#~ " existing tensor network, interpreting it"
#~ " as an adjoint vector (row vector)."
#~ " Args:"
#~ msgstr ""

#~ msgid ""
#~ "subsystem_edges: The edges of the "
#~ "network to be used as the input"
#~ " edges. ref_nodes: Nodes used to "
#~ "refer to parts of the tensor "
#~ "network that are"
#~ msgstr ""

#~ msgid ""
#~ "not connected to any input or "
#~ "output edges (for example: a scalar "
#~ "factor)."
#~ msgstr ""

#~ msgid "ignore_edges: Optional collection of edges to ignore when performing"
#~ msgstr ""

#~ msgid "consistency checks."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuAdjointVector` directly from"
#~ " a single tensor. This first wraps"
#~ " the tensor in a `Node`, then "
#~ "constructs the `QuAdjointVector` from that "
#~ "`Node`. Args:"
#~ msgstr ""

#~ msgid ""
#~ "tensor: The tensor. subsystem_axes: Sequence"
#~ " of integer indices specifying the "
#~ "order in which"
#~ msgstr ""

#~ msgid ""
#~ "to interpret the axes as subsystems "
#~ "(input edges). If not specified, the "
#~ "axes are taken in ascending order."
#~ msgstr ""

#~ msgid "backend: Optionally specify the backend to use for computations."
#~ msgstr ""

#~ msgid ""
#~ "Creates a new `QuOperator` from a "
#~ "tensor network. This encapsulates an "
#~ "existing tensor network, interpreting it "
#~ "as a linear operator. The network "
#~ "is checked for consistency: All dangling"
#~ " edges must either be in `out_edges`,"
#~ " `in_edges`, or `ignore_edges`. Args:"
#~ msgstr ""

#~ msgid ""
#~ "out_edges: The edges of the network "
#~ "to be used as the output edges."
#~ " in_edges: The edges of the network"
#~ " to be used as the input edges."
#~ " ref_nodes: Nodes used to refer to"
#~ " parts of the tensor network that "
#~ "are"
#~ msgstr ""

#~ msgid "ignore_edges: Optional collection of dangling edges to ignore when"
#~ msgstr ""

#~ msgid "performing consistency checks."
#~ msgstr ""

#~ msgid ""
#~ "Contract the tensor network in place."
#~ " This modifies the tensor network "
#~ "representation of the operator (or "
#~ "vector, or scalar), reducing it to "
#~ "a single tensor, without changing the"
#~ " value. Args:"
#~ msgstr ""

#~ msgid "contractor: A function that performs the contraction. Defaults to"
#~ msgstr ""

#~ msgid ""
#~ "`greedy`, which uses the greedy "
#~ "algorithm from `opt_einsum` to determine "
#~ "a contraction order."
#~ msgstr ""

#~ msgid ""
#~ "final_edge_order: Manually specify the axis"
#~ " ordering of the final tensor."
#~ msgstr ""

#~ msgid ""
#~ "The default ordering is determined by"
#~ " `out_edges` and `in_edges` (see above)."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuOperator` directly from a"
#~ " single tensor. This first wraps the"
#~ " tensor in a `Node`, then constructs"
#~ " the `QuOperator` from that `Node`. "
#~ "Args:"
#~ msgstr ""

#~ msgid ""
#~ "tensor: The tensor. out_axes: The axis"
#~ " indices of `tensor` to use as "
#~ "`out_edges`. in_axes: The axis indices "
#~ "of `tensor` to use as `in_edges`. "
#~ "backend: Optionally specify the backend "
#~ "to use for computations."
#~ msgstr ""

#~ msgid ""
#~ "The partial trace of the operator. "
#~ "Subsystems to trace out are supplied "
#~ "as indices, so that dangling edges "
#~ "are connected to eachother as:"
#~ msgstr ""

#~ msgid ""
#~ "This does not modify the original "
#~ "network. The original ordering of the"
#~ " remaining subsystems is maintained. Args:"
#~ msgstr ""

#~ msgid "subsystems_to_trace_out: Indices of subsystems to trace out."
#~ msgstr ""

#~ msgid ""
#~ "Tensor product with another operator. "
#~ "Given two operators `A` and `B`, "
#~ "produces a new operator `AB` "
#~ "representing `A` ⊗ `B`. The `out_edges`"
#~ " (`in_edges`) of `AB` is simply the"
#~ " concatenation of the `out_edges` "
#~ "(`in_edges`) of `A.copy()` with that of"
#~ " `B.copy()`: `new_out_edges = [*out_edges_A_copy,"
#~ " *out_edges_B_copy]` `new_in_edges = "
#~ "[*in_edges_A_copy, *in_edges_B_copy]` Args:"
#~ msgstr ""

#~ msgid "other: The other operator (`B`)."
#~ msgstr ""

#~ msgid ""
#~ "Constructs a new `QuScalar` from a "
#~ "tensor network. This encapsulates an "
#~ "existing tensor network, interpreting it "
#~ "as a scalar. Args:"
#~ msgstr ""

#~ msgid "ref_nodes: Nodes used to refer to the tensor network (need not be"
#~ msgstr ""

#~ msgid ""
#~ "exhaustive - one node from each "
#~ "disconnected subnetwork is sufficient). "
#~ "ignore_edges: Optional collection of edges "
#~ "to ignore when performing consistency "
#~ "checks."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuScalar` directly from a"
#~ " single tensor. This first wraps the"
#~ " tensor in a `Node`, then constructs"
#~ " the `QuScalar` from that `Node`. "
#~ "Args:"
#~ msgstr ""

#~ msgid ""
#~ "tensor: The tensor. backend: Optionally "
#~ "specify the backend to use for "
#~ "computations."
#~ msgstr ""

#~ msgid ""
#~ "Constructs a new `QuVector` from a "
#~ "tensor network. This encapsulates an "
#~ "existing tensor network, interpreting it "
#~ "as a (column) vector. Args:"
#~ msgstr ""

#~ msgid ""
#~ "subsystem_edges: The edges of the "
#~ "network to be used as the output"
#~ " edges. ref_nodes: Nodes used to "
#~ "refer to parts of the tensor "
#~ "network that are"
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuVector` directly from a"
#~ " single tensor. This first wraps the"
#~ " tensor in a `Node`, then constructs"
#~ " the `QuVector` from that `Node`. "
#~ "Args:"
#~ msgstr ""

#~ msgid ""
#~ "to interpret the axes as subsystems "
#~ "(output edges). If not specified, the"
#~ " axes are taken in ascending order."
#~ msgstr ""

#~ msgid ""
#~ "Check the vector spaces represented by"
#~ " two lists of edges are compatible."
#~ " The number of edges must be "
#~ "the same and the dimensions of "
#~ "each pair of edges must match. "
#~ "Otherwise, an exception is raised. Args:"
#~ msgstr ""

#~ msgid ""
#~ "edges_1: List of edges representing a"
#~ " many-body Hilbert space. edges_2: "
#~ "List of edges representing a many-"
#~ "body Hilbert space."
#~ msgstr ""

#~ msgid ""
#~ "Eliminates any connected CopyNodes that "
#~ "are identity matrices. This will modify"
#~ " the network represented by `nodes`. "
#~ "Only identities that are connected to"
#~ " other nodes are eliminated. Args:"
#~ msgstr ""

#~ msgid "nodes: Collection of nodes to search."
#~ msgstr ""

#~ msgid ""
#~ "nodes_dict: Dictionary mapping remaining Nodes"
#~ " to any replacements. dangling_edges_dict: "
#~ "Dictionary specifying all dangling-edge "
#~ "replacements."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuOperator` representing the "
#~ "identity on a given space. Internally,"
#~ " this is done by constructing "
#~ "`CopyNode`s for each edge, with "
#~ "dimension according to `space`. Args:"
#~ msgstr ""

#~ msgid "space: A sequence of integers for the dimensions of the tensor product"
#~ msgstr ""

#~ msgid "factors of the space (the edges in the tensor network)."
#~ msgstr ""

#~ msgid ""
#~ "backend: Optionally specify the backend "
#~ "to use for computations. dtype: The "
#~ "data type (for conversion to dense)."
#~ msgstr ""

#~ msgid ""
#~ "Constructs an appropriately specialized "
#~ "QuOperator. If there are no edges, "
#~ "creates a QuScalar. If the are "
#~ "only output (input) edges, creates a "
#~ "QuVector (QuAdjointVector). Otherwise creates "
#~ "a QuOperator. Args:"
#~ msgstr ""

#~ msgid ""
#~ "out_edges: output edges. in_edges: in "
#~ "edges. ref_nodes: reference nodes for "
#~ "the tensor network (needed if there "
#~ "is a"
#~ msgstr ""

#~ msgid "scalar component)."
#~ msgstr ""

#~ msgid "ignore_edges: edges to ignore when checking the dimensionality of the"
#~ msgstr ""

#~ msgid "tensor network."
#~ msgstr ""

#~ msgid "The object."
#~ msgstr ""

#~ msgid "compute reduced density matrix from quantum state ``state``"
#~ msgstr ""

#~ msgid "Return expm of ``a``, matrix exponential."
#~ msgstr ""

#~ msgid "Return cos of ``a``."
#~ msgstr ""

#~ msgid "cos of ``a``"
#~ msgstr ""

#~ msgid "Return 1.j in as tensor comoatible with backend."
#~ msgstr ""

#~ msgid "Return elementwise imaginary value of ``a``."
#~ msgstr ""

#~ msgid "Return boolean on whether ``a`` is a tensor in backend package."
#~ msgstr ""

#~ msgid "Return kronecker product of two matrix ``a`` and ``b``."
#~ msgstr ""

#~ msgid "Return numpy array of tensor ``a``, may not work in jitted function."
#~ msgstr ""

#~ msgid "Return elementwise real value of ``a``."
#~ msgstr ""

#~ msgid "Return sin of ``a``."
#~ msgstr ""

#~ msgid "sin of ``a``"
#~ msgstr ""

#~ msgid "Solve linear system Ax=b and return x"
#~ msgstr ""

#~ msgid ""
#~ "This function is jittable in theory. "
#~ "But only jax+GPU combination is "
#~ "recommended for jit, since the graph "
#~ "building time is too long for "
#~ "other backend options, though the "
#~ "running time of the function is "
#~ "very fast for every case."
#~ msgstr ""

#~ msgid ""
#~ "random tensor between 0 or 1, "
#~ "defaults to None, the random number "
#~ "will generated automatically"
#~ msgstr ""

#~ msgid "[WIP], check whether the circuit is legal"
#~ msgstr ""

#~ msgid ""
#~ "middle measurement in z basis on "
#~ "the circuit, note the wavefunction "
#~ "output is not normalized with "
#~ "``mid_measurement`` involved, one should "
#~ "normalized the state manually if needed."
#~ msgstr ""

#~ msgid "Compute the output wavefunction from the circuit"
#~ msgstr ""

#~ msgid "To set the runtime numerical dtype of tensors"
#~ msgstr ""

#~ msgid ""
#~ "Apply a double qubit gate on "
#~ "adjacent qubits of Matrix Product States"
#~ " (MPS), truncation rule is specified "
#~ "by `set_truncation_rule`."
#~ msgstr ""

#~ msgid ""
#~ "Apply a double qubit gate on MPS,"
#~ " truncation rule is specified by "
#~ "`set_truncation_rule`."
#~ msgstr ""

#~ msgid ""
#~ "Apply a single qubit gate on MPS,"
#~ " the gate must be unitary, no "
#~ "truncation is needed."
#~ msgstr ""

#~ msgid "Compute expectation of the corresponding double qubit gate"
#~ msgstr ""

#~ msgid ""
#~ "Compute expectation of the direct "
#~ "product of the corresponding two gates"
#~ msgstr ""

#~ msgid ""
#~ "Middle measurement in z basis on "
#~ "the circuit, note the wavefunction "
#~ "output is not normalized with "
#~ "``mid_measurement`` involved, one should "
#~ "normalized the state manually if needed."
#~ msgstr ""

#~ msgid "compute entropy from given density matrix ``rho``"
#~ msgstr ""

#~ msgid ""
#~ "Simulate measuring each qubit of ``p``"
#~ " in the computational basis, producing "
#~ "output like that of ``qiskit``. "
#~ "Parameters ---------- state : vector or"
#~ " operator"
#~ msgstr ""

#~ msgid "C"
#~ msgstr ""

#~ msgid "int"
#~ msgstr ""

#~ msgid "phys_dim"
#~ msgstr ""

#~ msgid "int, optional"
#~ msgstr ""

#~ msgid "The assumed size of the subsystems of ``p``, defaults to 2 for qubits."
#~ msgstr ""

#~ msgid "results"
#~ msgstr ""

#~ msgid "Tuple[]"
#~ msgstr ""

#~ msgid ""
#~ "Compute the following with several input"
#~ " ``o`` as tensor or ``QuOperator``"
#~ msgstr ""

#~ msgid "tensorcircuit  API"
#~ msgstr ""

#~ msgid "tensorcircuit.backends module"
#~ msgstr ""

#~ msgid "tensorcircuit.backends.backend_factory module"
#~ msgstr ""

#~ msgid "backend register"
#~ msgstr ""

#~ msgid "Get the `tc.backend` object"
#~ msgstr ""

#~ msgid "Parameters"
#~ msgstr ""

#~ msgid "\"numpy\", \"tensorflow\", \"jax\", \"pytorch\""
#~ msgstr ""

#~ msgid "Raises"
#~ msgstr ""

#~ msgid "Backend doesn't exist for `backend` argument."
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "The `tc.backend` object that with all registered universal functions."
#~ msgstr ""

#~ msgid "Return type"
#~ msgstr ""

#~ msgid "tensorcircuit.backends.jax_backend module"
#~ msgstr ""

#~ msgid "backend magic inherited from tensornetwork: jax backend"
#~ msgstr ""

#~ msgid "Bases: :class:`tensornetwork.backends.jax.jax_backend.JaxBackend`"
#~ msgstr ""

#~ msgid ""
#~ "see the original backend API at "
#~ "`jax backend "
#~ "<https://github.com/google/TensorNetwork/blob/master/tensornetwork/backends/jax/jax_backend.py>`_"
#~ msgstr ""

#~ msgid "Returns the elementwise absolute value of tensor. Args:"
#~ msgstr ""

#~ msgid "tensor: An input tensor."
#~ msgstr ""

#~ msgid "Returns:"
#~ msgstr ""

#~ msgid "tensor: Its elementwise absolute value."
#~ msgstr ""

#~ msgid "Return the index of maximum of an array an axis."
#~ msgstr ""

#~ msgid "[description]"
#~ msgstr ""

#~ msgid "[description], defaults to 0, different behavior from numpy defaults!"
#~ msgstr ""

#~ msgid "Return the index of minimum of an array an axis."
#~ msgstr ""

#~ msgid "Cast the tensor dtype of a ``a``."
#~ msgstr ""

#~ msgid "tensor"
#~ msgstr ""

#~ msgid "\"float32\", \"float64\", \"complex64\", \"complex128\""
#~ msgstr ""

#~ msgid "``a`` of new dtype"
#~ msgstr ""

#~ msgid "Join a sequence of arrays along an existing axis."
#~ msgstr ""

#~ msgid "[description], defaults to 0"
#~ msgstr ""

#~ msgid ""
#~ "the native cond for XLA compiling, "
#~ "wrapper for ``tf.cond`` and limited "
#~ "functionality of ``jax.lax.cond``"
#~ msgstr ""

#~ msgid "Convert a np.array or a tensor to a tensor type for the backend."
#~ msgstr ""

#~ msgid ""
#~ "generate coo format sparse matrix from"
#~ " indices and values, the only sparse"
#~ " format supported in different ML "
#~ "backends"
#~ msgstr ""

#~ msgid "shape [n, 2] for n non zero values in the returned matrix"
#~ msgstr ""

#~ msgid "shape [n]"
#~ msgstr ""

#~ msgid "Tuple[int, ...]"
#~ msgstr ""

#~ msgid "Return the expm of ``a``, matrix exponential."
#~ msgstr ""

#~ msgid "tensor in matrix form"
#~ msgstr ""

#~ msgid "matrix exponential of matrix ``a``"
#~ msgstr ""

#~ msgid "Return the cosine of a tensor ``a``."
#~ msgstr ""

#~ msgid "cosine of ``a``"
#~ msgstr ""

#~ msgid "Return the cumulative sum of the elements along a given axis."
#~ msgstr ""

#~ msgid ""
#~ "The default behavior is the same "
#~ "as numpy, different from tf/torch as "
#~ "cumsum of the flattern 1D array, "
#~ "defaults to None"
#~ msgstr ""

#~ msgid "Return the copy of tensor ''a''."
#~ msgstr ""

#~ msgid "Return an identity matrix of dimension `dim`"
#~ msgstr ""

#~ msgid ""
#~ "Depending on specific backends, `dim` "
#~ "has to be either an int (numpy,"
#~ " torch, tensorflow) or a `ShapeType` "
#~ "object (for block-sparse backends). "
#~ "Block-sparse behavior is currently not "
#~ "supported"
#~ msgstr ""

#~ msgid "Args:"
#~ msgstr ""

#~ msgid ""
#~ "N (int): The dimension of the "
#~ "returned matrix. dtype: The dtype of "
#~ "the returned matrix. M (int): The "
#~ "dimension of the returned matrix."
#~ msgstr ""

#~ msgid "Return function which is the grad function of input ``f``"
#~ msgstr ""

#~ msgid "function to be differentiated"
#~ msgstr ""

#~ msgid ""
#~ "the position of args in ``f`` that"
#~ " are to be differentiated, defaults "
#~ "to 0"
#~ msgstr ""

#~ msgid "the grad fuction of ``f`` with the same set of arguments as ``f``"
#~ msgstr ""

#~ msgid "Return 1.j in as a tensor compatible with the backend."
#~ msgstr ""

#~ msgid "\"complex64\" or \"complex128\""
#~ msgstr ""

#~ msgid "1.j tensor"
#~ msgstr ""

#~ msgid "Return the elementwise imaginary value of a tensor ``a``."
#~ msgstr ""

#~ msgid "imaginary value of ``a``"
#~ msgstr ""

#~ msgid "[summary]"
#~ msgstr ""

#~ msgid "The possible options"
#~ msgstr ""

#~ msgid "Sampling output shape"
#~ msgstr ""

#~ msgid ""
#~ "probability for each option in a, "
#~ "defaults to None, as equal probability"
#~ " distribution"
#~ msgstr ""

#~ msgid ""
#~ "Call random normal function with the "
#~ "random state management behind the "
#~ "scene."
#~ msgstr ""

#~ msgid "[description], defaults to 1"
#~ msgstr ""

#~ msgid "[description], defaults to \"32\""
#~ msgstr ""

#~ msgid "determine whether the type of input ``a`` is of sparse type"
#~ msgstr ""

#~ msgid "Return a boolean on whether ``a`` is a tensor in backend package."
#~ msgstr ""

#~ msgid "a tensor to be determined"
#~ msgstr ""

#~ msgid "whether ``a`` is a tensor"
#~ msgstr ""

#~ msgid "Return jitted version function of ``f``"
#~ msgstr ""

#~ msgid "function to be jitted"
#~ msgstr ""

#~ msgid ""
#~ "index of args that doesn't regarded "
#~ "as tensor, only work for jax "
#~ "backend"
#~ msgstr ""

#~ msgid ""
#~ "whether open XLA compliation, only works"
#~ " for tensorflow backend, defaults False "
#~ "since several ops has no XLA "
#~ "correspondence"
#~ msgstr ""

#~ msgid "jitted ``f``"
#~ msgstr ""

#~ msgid ""
#~ "Function that computes a (forward-mode)"
#~ " Jacobian-vector product of ``f``. "
#~ "Strictly speaking, this function is "
#~ "value_and_jvp"
#~ msgstr ""

#~ msgid "The function to compute jvp"
#~ msgstr ""

#~ msgid "primals"
#~ msgstr ""

#~ msgid "tangents"
#~ msgstr ""

#~ msgid ""
#~ "(``f(*inputs)``, jvp_tensor), where jvp_tensor "
#~ "is the same shape as output of "
#~ "``f``"
#~ msgstr ""

#~ msgid "Return the kronecker product of two matrices ``a`` and ``b``."
#~ msgstr ""

#~ msgid "kronecker product of ``a`` and ``b``"
#~ msgstr ""

#~ msgid "Return the maximum of an array or maximum along an axis."
#~ msgstr ""

#~ msgid "[description], defaults to None"
#~ msgstr ""

#~ msgid "Return the minimum of an array or minimum along an axis."
#~ msgstr ""

#~ msgid ""
#~ "Return the numpy array of a tensor"
#~ " ``a``, but may not work in a"
#~ " jitted function."
#~ msgstr ""

#~ msgid "numpy array of ``a``"
#~ msgstr ""

#~ msgid ""
#~ "One-hot encodes the given ``a``. "
#~ "Each index in the input ``a`` is"
#~ " encoded as a vector of zeros "
#~ "of length ``num`` with the element "
#~ "at index set to one:"
#~ msgstr ""

#~ msgid "input tensor"
#~ msgstr ""

#~ msgid "number of features in onehot dimension"
#~ msgstr ""

#~ msgid "onehot tensor with the last extra dimension"
#~ msgstr ""

#~ msgid ""
#~ "Return an ones-matrix of dimension "
#~ "`dim` Depending on specific backends, "
#~ "`dim` has to be either an int "
#~ "(numpy, torch, tensorflow) or a "
#~ "`ShapeType` object (for block-sparse "
#~ "backends). Block-sparse behavior is "
#~ "currently not supported Args:"
#~ msgstr ""

#~ msgid ""
#~ "shape (int): The dimension of the "
#~ "returned matrix. dtype: The dtype of "
#~ "the returned matrix."
#~ msgstr ""

#~ msgid ""
#~ "A jax like split API, but does't"
#~ " split the key generator for other"
#~ " backends. just for a consistent "
#~ "interface of random code, be careful "
#~ "that you know what the function "
#~ "actually does."
#~ msgstr ""

#~ msgid "Return the elementwise real value of a tensor ``a``."
#~ msgstr ""

#~ msgid "real value of ``a``"
#~ msgstr ""

#~ msgid ""
#~ "Rectified linear unit activation function. "
#~ "Computes the element-wise function:"
#~ msgstr ""

#~ msgid "\\mathrm{relu}(x)=\\max(x,0)"
#~ msgstr ""

#~ msgid "Input tensor"
#~ msgstr ""

#~ msgid "Tensor after relu"
#~ msgstr ""

#~ msgid ""
#~ "Roughly equivalent to operand[indices] = "
#~ "updates, indices only support shape with"
#~ " rank 2 for now"
#~ msgstr ""

#~ msgid "Set the random state attached in the backend"
#~ msgstr ""

#~ msgid "int, defaults to None"
#~ msgstr ""

#~ msgid "Return the  elementwise sine of a tensor ``a``."
#~ msgstr ""

#~ msgid "sine of ``a``"
#~ msgstr ""

#~ msgid "Return the total number of elements in ``a`` in tensor form."
#~ msgstr ""

#~ msgid "the total number of elements in ``a``"
#~ msgstr ""

#~ msgid ""
#~ "Softmax function. Computes the function "
#~ "which rescales elements to the range "
#~ "[0,1] such that the elements along "
#~ "axis sum to 1."
#~ msgstr ""

#~ msgid "\\mathrm{softmax}(x) = \\frac{\\exp(x_i)}{\\sum_j \\exp(x_j)}"
#~ msgstr ""

#~ msgid "Tensor"
#~ msgstr ""

#~ msgid ""
#~ "A dimension along which Softmax will "
#~ "be computed , defaults to None for"
#~ " all axis sum."
#~ msgstr ""

#~ msgid "concatenated tensor"
#~ msgstr ""

#~ msgid "Solve the linear system Ax=b and return x"
#~ msgstr ""

#~ msgid "The multiplied matrix."
#~ msgstr ""

#~ msgid "The resulted matrix."
#~ msgstr ""

#~ msgid "The solution of the linear system."
#~ msgstr ""

#~ msgid "sparse matrix times dense matrix"
#~ msgstr ""

#~ msgid "dense matrix"
#~ msgstr ""

#~ msgid ""
#~ "Concatenates a sequence of tensors ``a``"
#~ " along a new dimension ``axis``."
#~ msgstr ""

#~ msgid "List of tensors in the same shape"
#~ msgstr ""

#~ msgid "the stack axis, defaults to 0"
#~ msgstr ""

#~ msgid "stateful register for each package"
#~ msgstr ""

#~ msgid "shape of output sampling tensor"
#~ msgstr ""

#~ msgid "only real data type is supported, \"32\" or \"64\", defaults to \"32\""
#~ msgstr ""

#~ msgid "Uniform random sampler from ``low`` to ``high``."
#~ msgstr ""

#~ msgid "shape of output sampling tensor, defaults to 1"
#~ msgstr ""

#~ msgid "stop backpropagation from a"
#~ msgstr ""

#~ msgid "``branches[index]()``"
#~ msgstr ""

#~ msgid "Constructs a tensor by tiling a given tensor."
#~ msgstr ""

#~ msgid "1d tensor with length the same as the rank of ``a``"
#~ msgstr ""

#~ msgid "convert sparse matrix to dense tensor"
#~ msgstr ""

#~ msgid ""
#~ "Find the unique elements and their "
#~ "corresponding counts of the given tensor"
#~ " ``a``."
#~ msgstr ""

#~ msgid "Unique elements, corresponding counts"
#~ msgstr ""

#~ msgid "Return function which returns the value and grad of ``f``"
#~ msgstr ""

#~ msgid ""
#~ "the value and grad fuction of "
#~ "``f`` with the same set of "
#~ "arguments as ``f``"
#~ msgstr ""

#~ msgid ""
#~ "Return vvag function of ``f``. the "
#~ "inputs for ``f`` is (args[0], args[1],"
#~ " args[2], ...), and the output of "
#~ "``f`` is a scalar. Suppose vvag(f) "
#~ "is a function with inputs in the"
#~ " form (vargs[0], args[1], args[2], ...),"
#~ " where vagrs[0] has one extra "
#~ "dimension than args[0] in the first "
#~ "axis and consistent with args[0] in "
#~ "shape for remaining dimensions, i.e. "
#~ "shape(vargs[0]) = [batch] + shape(args[0])."
#~ " (We only cover case where "
#~ "``vectorized_argnums`` defaults to 0 here "
#~ "for demonstration). vvag(f) returns a "
#~ "tuple as a value tensor with shape"
#~ " [batch, 1] and a gradient tuple "
#~ "with shape: ([batch]+shape(args[argnum]) for "
#~ "argnum in argnums). The gradient for "
#~ "argnums=k is defined as"
#~ msgstr ""

#~ msgid ""
#~ "g^k = \\frac{\\partial \\sum_{i\\in batch} "
#~ "f(vargs[0][i], args[1], ...)}{\\partial args[k]}"
#~ msgstr ""

#~ msgid "Therefore, if argnums=0, the gradient is reduced to"
#~ msgstr ""

#~ msgid "g^0_i = \\frac{\\partial f(vargs[0][i])}{\\partial vargs[0][i]}"
#~ msgstr ""

#~ msgid ""
#~ ", which is specifically suitable for "
#~ "batched VQE optimization, where args[0] "
#~ "is the circuit parameters."
#~ msgstr ""

#~ msgid "And if argnums=1, the gradient is like"
#~ msgstr ""

#~ msgid ""
#~ "g^1_i = \\frac{\\partial \\sum_j "
#~ "f(vargs[0][j], args[1])}{\\partial args[1][i]}\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ ", which is suitable for quantum "
#~ "machine learning scenarios, where ``f`` "
#~ "is the loss function, args[0] "
#~ "corresponds the input data and args[1]"
#~ " corresponds to the weights in the"
#~ " QML model."
#~ msgstr ""

#~ msgid ""
#~ "the args to be vectorized, these "
#~ "arguments should share the same batch"
#~ " shape in the fist dimension"
#~ msgstr ""

#~ msgid ""
#~ "Function that computes the dot product"
#~ " between a vector v and the "
#~ "Jacobian of the given function at "
#~ "the point given by the inputs. "
#~ "(reverse mode AD relevant) Strictly "
#~ "speaking, this function is value_and_vjp."
#~ msgstr ""

#~ msgid "The function to carry out vjp calculation"
#~ msgstr ""

#~ msgid "input for ``f``"
#~ msgstr ""

#~ msgid ""
#~ "value vector or gradient from downstream"
#~ " in reserse mode AD the same "
#~ "shape as return of function ``f``"
#~ msgstr ""

#~ msgid ""
#~ "(``f(*inputs)``, vjp_tensor), where vjp_tensor "
#~ "is the same shape as inputs"
#~ msgstr ""

#~ msgid ""
#~ "Return vectorized map or batched version"
#~ " of ``f`` on the first extra "
#~ "axis, the general interface support "
#~ "``f`` with multiple arguments and "
#~ "broadcast in the fist dimension."
#~ msgstr ""

#~ msgid "function to be broadcasted."
#~ msgstr ""

#~ msgid "vmap version of ``f``"
#~ msgstr ""

#~ msgid ""
#~ "Return a zeros-matrix of dimension "
#~ "`dim` Depending on specific backends, "
#~ "`dim` has to be either an int "
#~ "(numpy, torch, tensorflow) or a "
#~ "`ShapeType` object (for block-sparse "
#~ "backends)."
#~ msgstr ""

#~ msgid "Block-sparse behavior is currently not supported Args:"
#~ msgstr ""

#~ msgid "Bases: :class:`object`"
#~ msgstr ""

#~ msgid "tensorcircuit.backends.numpy_backend module"
#~ msgstr ""

#~ msgid "backend magic inherited from tensornetwork: numpy backend"
#~ msgstr ""

#~ msgid "Bases: :class:`tensornetwork.backends.numpy.numpy_backend.NumPyBackend`"
#~ msgstr ""

#~ msgid ""
#~ "see the original backend API at "
#~ "`numpy backend "
#~ "<https://github.com/google/TensorNetwork/blob/master/tensornetwork/backends/numpy/numpy_backend.py>`_"
#~ msgstr ""

#~ msgid "tensorcircuit.backends.pytorch_backend module"
#~ msgstr ""

#~ msgid "backend magic inherited from tensornetwork: pytorch backend"
#~ msgstr ""

#~ msgid ""
#~ "Bases: "
#~ ":class:`tensornetwork.backends.pytorch.pytorch_backend.PyTorchBackend`"
#~ msgstr ""

#~ msgid ""
#~ "see the original backend API at "
#~ "`pytorch backend "
#~ "<https://github.com/google/TensorNetwork/blob/master/tensornetwork/backends/pytorch/pytorch_backend.py>`_"
#~ msgstr ""

#~ msgid ""
#~ "Note the functionality provided by "
#~ "pytorch backend is incomplete, it "
#~ "currenly lacks native efficicent jit and"
#~ " vmap support."
#~ msgstr ""

#~ msgid "tensorcircuit.backends.tensorflow_backend module"
#~ msgstr ""

#~ msgid "backend magic inherited from tensornetwork: tensorflow backend"
#~ msgstr ""

#~ msgid ""
#~ "Bases: "
#~ ":class:`tensornetwork.backends.tensorflow.tensorflow_backend.TensorFlowBackend`"
#~ msgstr ""

#~ msgid ""
#~ "see the original backend API at "
#~ "`tensorflow backend "
#~ "<https://github.com/google/TensorNetwork/blob/master/tensornetwork/backends/tensorflow/tensorflow_backend.py>`_"
#~ msgstr ""

#~ msgid "tensorcircuit.channels module"
#~ msgstr ""

#~ msgid "some common noise quantum channels"
#~ msgstr ""

#~ msgid ""
#~ "Return an amplitude damping channel. "
#~ "Notice: Amplitude damping corrspondings to "
#~ "p = 1."
#~ msgstr ""

#~ msgid ""
#~ "\\sqrt{p}\n"
#~ "\\begin{bmatrix}\n"
#~ "    1 & 0\\\\\n"
#~ "    0 & \\sqrt{1-\\gamma}\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\sqrt{p}\n"
#~ "\\begin{bmatrix}\n"
#~ "    0 & \\sqrt{\\gamma}\\\\\n"
#~ "    0 & 0\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\sqrt{1-p}\n"
#~ "\\begin{bmatrix}\n"
#~ "    \\sqrt{1-\\gamma} & 0\\\\\n"
#~ "    0 & 1\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\sqrt{1-p}\n"
#~ "\\begin{bmatrix}\n"
#~ "    0 & 0\\\\\n"
#~ "    \\sqrt{\\gamma} & 0\\\\\n"
#~ "\\end{bmatrix}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "Example:"
#~ msgstr ""

#~ msgid "the damping parameter of amplitude (:math:`\\gamma`)"
#~ msgstr ""

#~ msgid ":math:`p`"
#~ msgstr ""

#~ msgid "An amplitude damping channel with given :math:`\\gamma` and :math:`p`"
#~ msgstr ""

#~ msgid "Return a Depolarizing Channel"
#~ msgstr ""

#~ msgid ""
#~ "\\sqrt{1-p_x-p_y-p_z}\n"
#~ "\\begin{bmatrix}\n"
#~ "    1 & 0\\\\\n"
#~ "    0 & 1\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\sqrt{p_x}\n"
#~ "\\begin{bmatrix}\n"
#~ "    0 & 1\\\\\n"
#~ "    1 & 0\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\sqrt{p_y}\n"
#~ "\\begin{bmatrix}\n"
#~ "    0 & -1j\\\\\n"
#~ "    1j & 0\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\sqrt{p_z}\n"
#~ "\\begin{bmatrix}\n"
#~ "    1 & 0\\\\\n"
#~ "    0 & -1\\\\\n"
#~ "\\end{bmatrix}\n"
#~ "\n"
#~ msgstr ""

#~ msgid ":math:`p_x`"
#~ msgstr ""

#~ msgid ":math:`p_y`"
#~ msgstr ""

#~ msgid ":math:`p_z`"
#~ msgstr ""

#~ msgid "Sequences of Gates"
#~ msgstr ""

#~ msgid "Convert Kraus operators to one Tensor (as one Super Gate)."
#~ msgstr ""

#~ msgid ""
#~ "\\sum_{k}^{} K_k \\otimes K_k^{\\dagger}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "A sequence of Gate"
#~ msgstr ""

#~ msgid "The corresponding Tensor of the list of Kraus operators"
#~ msgstr ""

#~ msgid "Return a phase damping channel with given :math:`\\gamma`"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}\n"
#~ "    1 & 0\\\\\n"
#~ "    0 & \\sqrt{1-\\gamma}\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\begin{bmatrix}\n"
#~ "    0 & 0\\\\\n"
#~ "    0 & \\sqrt{\\gamma}\\\\\n"
#~ "\\end{bmatrix}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "The damping parameter of phase (:math:`\\gamma`)"
#~ msgstr ""

#~ msgid "A phase damping channel with given :math:`\\gamma`"
#~ msgstr ""

#~ msgid "Reset channel"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}\n"
#~ "    1 & 0\\\\\n"
#~ "    0 & 0\\\\\n"
#~ "\\end{bmatrix}\\qquad\n"
#~ "\\begin{bmatrix}\n"
#~ "    0 & 1\\\\\n"
#~ "    0 & 0\\\\\n"
#~ "\\end{bmatrix}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "Check identity of a single qubit Kraus operators."
#~ msgstr ""

#~ msgid "Examples:"
#~ msgstr ""

#~ msgid ""
#~ "\\sum_{k}^{} K_k^{\\dagger} K_k = I\n"
#~ "\n"
#~ msgstr ""

#~ msgid "List of Kraus operators."
#~ msgstr ""

#~ msgid "tensorcircuit.circuit module"
#~ msgstr ""

#~ msgid "quantum circuit: state simulator"
#~ msgstr ""

#~ msgid "``Circuit`` class. Simple usage demo below."
#~ msgstr ""

#~ msgid "Apply any gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Qubit number than the gate applies on."
#~ msgstr ""

#~ msgid "Parameters for the gate"
#~ msgstr ""

#~ msgid "Apply cnot gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j & 0.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 1.+0.j & 0.+0.j & "
#~ "0.+0.j\\\\    0.+0.j & 0.+0.j & 0.+0.j"
#~ " & 1.+0.j\\\\    0.+0.j & 0.+0.j &"
#~ " 1.+0.j & 0.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Qubit number than the gate applies on. The matrix for the gate is"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j & "
#~ "0.+0.j & 0.+0.j\\\\    0.+0.j & 1.+0.j"
#~ " & 0.+0.j & 0.+0.j\\\\    0.+0.j &"
#~ " 0.+0.j & 0.+0.j & 1.+0.j\\\\    "
#~ "0.+0.j & 0.+0.j & 1.+0.j & 0.+0.j"
#~ " \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply cr gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply crx gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply cry gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply crz gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply cy gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j & 0.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 1.+0.j & 0.+0.j & "
#~ "0.+0.j\\\\    0.+0.j & 0.+0.j & 0.+0.j"
#~ " & -0.-1.j\\\\    0.+0.j & 0.+0.j &"
#~ " 0.+1.j & 0.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j & "
#~ "0.+0.j & 0.+0.j\\\\    0.+0.j & 1.+0.j"
#~ " & 0.+0.j & 0.+0.j\\\\    0.+0.j &"
#~ " 0.+0.j & 0.+0.j & -0.-1.j\\\\    "
#~ "0.+0.j & 0.+0.j & 0.+1.j & 0.+0.j"
#~ " \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply cz gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j & 0.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 1.+0.j & 0.+0.j & "
#~ "0.+0.j\\\\    0.+0.j & 0.+0.j & 1.+0.j"
#~ " & 0.+0.j\\\\    0.+0.j & 0.+0.j &"
#~ " 0.+0.j & -1.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j & "
#~ "0.+0.j & 0.+0.j\\\\    0.+0.j & 1.+0.j"
#~ " & 0.+0.j & 0.+0.j\\\\    0.+0.j &"
#~ " 0.+0.j & 1.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 0.+0.j & 0.+0.j & -1.+0.j"
#~ " \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply exp gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply exp1 gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply h gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    "
#~ "0.70710677+0.j & 0.70710677+0.j\\\\    "
#~ "0.70710677+0.j & -0.70710677+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    0.70710677+0.j & "
#~ "0.70710677+0.j\\\\    0.70710677+0.j & "
#~ "-0.70710677+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply i gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j\\\\    0.+0.j & 1.+0.j "
#~ "\\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 1.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply iswap gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    "
#~ "1.000000e+00+0.j & 0.000000e+00+0.j & "
#~ "0.000000e+00+0.j & 0.000000e+00+0.j\\\\    "
#~ "0.000000e+00+0.j & 6.123234e-17+0.j & "
#~ "0.000000e+00+1.j & 0.000000e+00+0.j\\\\    "
#~ "0.000000e+00+0.j & 0.000000e+00+1.j & "
#~ "6.123234e-17+0.j & 0.000000e+00+0.j\\\\    "
#~ "0.000000e+00+0.j & 0.000000e+00+0.j & "
#~ "0.000000e+00+0.j & 1.000000e+00+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.000000e+00+0.j & "
#~ "0.000000e+00+0.j & 0.000000e+00+0.j & "
#~ "0.000000e+00+0.j\\\\    0.000000e+00+0.j & "
#~ "6.123234e-17+0.j & 0.000000e+00+1.j & "
#~ "0.000000e+00+0.j\\\\    0.000000e+00+0.j & "
#~ "0.000000e+00+1.j & 6.123234e-17+0.j & "
#~ "0.000000e+00+0.j\\\\    0.000000e+00+0.j & "
#~ "0.000000e+00+0.j & 0.000000e+00+0.j & "
#~ "1.000000e+00+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply r gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply rx gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply ry gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply rz gate with parameters on the circuit."
#~ msgstr ""

#~ msgid "Apply s gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j\\\\    0.+0.j & 0.+1.j "
#~ "\\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 0.+1.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply sd gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.-0.j "
#~ "& 0.-0.j\\\\    0.-0.j & 0.-1.j "
#~ "\\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.-0.j & 0.-0.j\\\\    "
#~ "0.-0.j & 0.-1.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply swap gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j & 0.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 0.+0.j & 1.+0.j & "
#~ "0.+0.j\\\\    0.+0.j & 1.+0.j & 0.+0.j"
#~ " & 0.+0.j\\\\    0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 1.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j & "
#~ "0.+0.j & 0.+0.j\\\\    0.+0.j & 0.+0.j"
#~ " & 1.+0.j & 0.+0.j\\\\    0.+0.j &"
#~ " 1.+0.j & 0.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 0.+0.j & 0.+0.j & 1.+0.j"
#~ " \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply t gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1. &"
#~ " +0.j & 0. & +0.j\\\\    0. &"
#~ " +0.j & 0.70710677+0.70710677j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1. & +0.j & 0. "
#~ "& +0.j\\\\    0. & +0.j & "
#~ "0.70710677+0.70710677j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply td gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1. &"
#~ " -0.j & 0. & -0.j\\\\    0. &"
#~ " -0.j & 0.70710677-0.70710677j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1. & -0.j & 0. "
#~ "& -0.j\\\\    0. & -0.j & "
#~ "0.70710677-0.70710677j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply toffoli gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j & 0.+0.j & 0.+0.j & "
#~ "0.+0.j & 0.+0.j & 0.+0.j & "
#~ "0.+0.j\\\\    0.+0.j & 1.+0.j & 0.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 0.+0.j\\\\    0.+0.j & "
#~ "0.+0.j & 1.+0.j & 0.+0.j & 0.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j\\\\"
#~ "    0.+0.j & 0.+0.j & 0.+0.j & "
#~ "1.+0.j & 0.+0.j & 0.+0.j & 0.+0.j"
#~ " & 0.+0.j\\\\    0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 0.+0.j & 1.+0.j & "
#~ "0.+0.j & 0.+0.j & 0.+0.j\\\\    0.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 1.+0.j & 0.+0.j & "
#~ "0.+0.j\\\\    0.+0.j & 0.+0.j & 0.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 1.+0.j\\\\    0.+0.j & "
#~ "0.+0.j & 0.+0.j & 0.+0.j & 0.+0.j"
#~ " & 0.+0.j & 1.+0.j & 0.+0.j "
#~ "\\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j & "
#~ "0.+0.j & 0.+0.j & 0.+0.j & 0.+0.j"
#~ " & 0.+0.j & 0.+0.j\\\\    0.+0.j &"
#~ " 1.+0.j & 0.+0.j & 0.+0.j & "
#~ "0.+0.j & 0.+0.j & 0.+0.j & "
#~ "0.+0.j\\\\    0.+0.j & 0.+0.j & 1.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 0.+0.j\\\\    0.+0.j & "
#~ "0.+0.j & 0.+0.j & 1.+0.j & 0.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j\\\\"
#~ "    0.+0.j & 0.+0.j & 0.+0.j & "
#~ "0.+0.j & 1.+0.j & 0.+0.j & 0.+0.j"
#~ " & 0.+0.j\\\\    0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 0.+0.j & 0.+0.j & "
#~ "1.+0.j & 0.+0.j & 0.+0.j\\\\    0.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j &"
#~ " 0.+0.j & 0.+0.j & 0.+0.j & "
#~ "1.+0.j\\\\    0.+0.j & 0.+0.j & 0.+0.j"
#~ " & 0.+0.j & 0.+0.j & 0.+0.j &"
#~ " 1.+0.j & 0.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply wroot gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    "
#~ "0.70710677+0.j & -0.5 & -0.5j\\\\    0.5"
#~ " & -0.5j & 0.70710677+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    0.70710677+0.j & -0.5 &"
#~ " -0.5j\\\\    0.5 & -0.5j & "
#~ "0.70710677+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply x gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    0.+0.j "
#~ "& 1.+0.j\\\\    1.+0.j & 0.+0.j "
#~ "\\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    0.+0.j & 1.+0.j\\\\    "
#~ "1.+0.j & 0.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply y gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    0.+0.j "
#~ "& -0.-1.j\\\\    0.+1.j & 0.+0.j "
#~ "\\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    0.+0.j & -0.-1.j\\\\    "
#~ "0.+1.j & 0.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Apply z gate on the circuit."
#~ msgstr ""

#~ msgid ""
#~ "Qubit number than the gate applies "
#~ "on. The matrix for the gate is"
#~ "  .. math::        \\begin{bmatrix}    1.+0.j "
#~ "& 0.+0.j\\\\    0.+0.j & -1.+0.j "
#~ "\\end{bmatrix}"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & -1.+0.j \\end{bmatrix}"
#~ msgstr ""

#~ msgid "Circuit object based on state simulator."
#~ msgstr ""

#~ msgid "The number of qubits in the circuit."
#~ msgstr ""

#~ msgid ""
#~ "If not None, the initial state of"
#~ " the circuit is taken as ``inputs``"
#~ " instead of :math:`\\vert 0\\rangle^n` "
#~ "qubits, defaults to None"
#~ msgstr ""

#~ msgid "(Nodes, dangling Edges) for a MPS like initial wavefunction"
#~ msgstr ""

#~ msgid ""
#~ "dict if two qubit gate is ready"
#~ " for split, including parameters for "
#~ "at least one of ``max_singular_values`` "
#~ "and ``max_truncation_err``."
#~ msgstr ""

#~ msgid ""
#~ "Monte Carlo trajectory simulation of "
#~ "general Kraus channel whose Kraus "
#~ "operators cannot be amplified to unitary"
#~ " operators. For unitary operators composed"
#~ " Kraus channel, :py:meth:`unitary_kraus` is "
#~ "much faster."
#~ msgstr ""

#~ msgid ""
#~ "This function is jittable in theory. "
#~ "But only jax+GPU combination is "
#~ "recommended for jit since the graph "
#~ "building time is too long for "
#~ "other backend options; though the "
#~ "running time of the function is "
#~ "very fast for every case."
#~ msgstr ""

#~ msgid "list of ``tn.Node`` for Kraus operators"
#~ msgstr ""

#~ msgid "the qubits index that Kraus channel is applied on"
#~ msgstr ""

#~ msgid ""
#~ "random tensor between 0 or 1, "
#~ "defaults to be None, the random "
#~ "number will be generated automatically"
#~ msgstr ""

#~ msgid "Compute expectation of corresponding operators"
#~ msgstr ""

#~ msgid ""
#~ "operator and its position on the "
#~ "circuit, eg. ``(tc.gates.z(), [1, ]), "
#~ "(tc.gates.x(), [2, ])`` is for operator"
#~ " :math:`Z_1X_2`"
#~ msgstr ""

#~ msgid ""
#~ "if True, then the wavefunction tensor"
#~ " is cached for further expectation "
#~ "evaluation, defaults to True"
#~ msgstr ""

#~ msgid "Tensor with one element"
#~ msgstr ""

#~ msgid "[WIP], check whether the circuit is legal."
#~ msgstr ""

#~ msgid "the bool indicating whether the circuit is legal"
#~ msgstr ""

#~ msgid "Take measurement to the given quantum lines."
#~ msgstr ""

#~ msgid "measure on which quantum line"
#~ msgstr ""

#~ msgid "if true, theoretical probability is also returned"
#~ msgstr ""

#~ msgid ""
#~ "Middle measurement in z-basis on the "
#~ "circuit, note the wavefunction output is"
#~ " not normalized with ``mid_measurement`` "
#~ "involved, one should normalize the state"
#~ " manually if needed."
#~ msgstr ""

#~ msgid "the index of qubit that the Z direction postselection applied on"
#~ msgstr ""

#~ msgid "0 for spin up, 1 for spin down, defaults to be 0"
#~ msgstr ""

#~ msgid "Reference: arXiv:1201.3974."
#~ msgstr ""

#~ msgid "sampled bit string and the corresponding theoretical probability"
#~ msgstr ""

#~ msgid "Replace the input state with the circuit structure unchanged."
#~ msgstr ""

#~ msgid "Input wavefunction."
#~ msgstr ""

#~ msgid ""
#~ "Replace the input state in MPS "
#~ "representation while keep the circuit "
#~ "structure unchanged."
#~ msgstr ""

#~ msgid "Compute the output wavefunction from the circuit."
#~ msgstr ""

#~ msgid "the str indicating the form of the output wavefunction"
#~ msgstr ""

#~ msgid "Tensor with the corresponding shape"
#~ msgstr ""

#~ msgid "Compute :math:`\\langle bra\\vert ops \\vert ket\\rangle`"
#~ msgstr ""

#~ msgid "Example 1 (:math:`bra` is same as :math:`ket`)"
#~ msgstr ""

#~ msgid "Example 2 (:math:`bra` is different from :math:`ket`)"
#~ msgstr ""

#~ msgid "[description], defaults to None, which is the same as ``ket``"
#~ msgstr ""

#~ msgid "[description], defaults to True"
#~ msgstr ""

#~ msgid "[description], defaults to False"
#~ msgstr ""

#~ msgid ""
#~ "Not an ideal visualization for quantum"
#~ " circuit, but reserve here as a "
#~ "general approch to show tensornetwork "
#~ "[Deperacted, use ``qir2tex instead``]"
#~ msgstr ""

#~ msgid "tensorcircuit.cons module"
#~ msgstr ""

#~ msgid "some constants and setups"
#~ msgstr ""

#~ msgid ""
#~ "To set runtime contractor of the "
#~ "tensornetwork for a better contraction "
#~ "path."
#~ msgstr ""

#~ msgid ""
#~ "\"auto\", \"greedy\", \"branch\", \"plain\", "
#~ "\"tng\", \"custom\", \"custom_stateful\". defaults"
#~ " to None (\"auto\")"
#~ msgstr ""

#~ msgid "Valid for \"custom\" or \"custom_stateful\" as method, defaults to None"
#~ msgstr ""

#~ msgid ""
#~ "It is not very useful, as "
#~ "``memory_limit`` leads to ``branch`` "
#~ "contraction instead of ``greedy`` which "
#~ "is rather slow, defaults to None"
#~ msgstr ""

#~ msgid "Tensornetwork version is too low to support some of the contractors."
#~ msgstr ""

#~ msgid "Unknown method options."
#~ msgstr ""

#~ msgid "The new tensornetwork with its contractor set."
#~ msgstr ""

#~ msgid "To set the runtime numerical dtype of tensors."
#~ msgstr ""

#~ msgid ""
#~ "\"complex64\" or \"complex128\", defaults to"
#~ " None, which is equivalent to "
#~ "\"complex64\"."
#~ msgstr ""

#~ msgid "The naive statevector simulator contraction path."
#~ msgstr ""

#~ msgid "The list of ``tn.Node``."
#~ msgstr ""

#~ msgid "The list of dangling node edges, defaults to None."
#~ msgstr ""

#~ msgid "The ``tn.Node`` after contraction"
#~ msgstr ""

#~ msgid "To set the runtime backend of tensorcircuit."
#~ msgstr ""

#~ msgid ""
#~ "Note: ``tc.set_backend`` and "
#~ "``tc.cons.set_tensornetwork_backend`` are the same."
#~ msgstr ""

#~ msgid ""
#~ "\"numpy\", \"tensorflow\", \"jax\", \"pytorch\". "
#~ "defaults to None, which gives the "
#~ "same behavior as "
#~ "``tensornetwork.backend_contextmanager.get_default_backend()``."
#~ msgstr ""

#~ msgid "Whether the object should be set as global."
#~ msgstr ""

#~ msgid "tensorcircuit.densitymatrix module"
#~ msgstr ""

#~ msgid "quantum circuit class but with density matrix simulator"
#~ msgstr ""

#~ msgid "tensorcircuit.densitymatrix2 module"
#~ msgstr ""

#~ msgid "quantum circuit class but with density matrix simulator: v2"
#~ msgstr ""

#~ msgid "Bases: :class:`tensorcircuit.densitymatrix.DMCircuit`"
#~ msgstr ""

#~ msgid "tensorcircuit.experimental module"
#~ msgstr ""

#~ msgid "experimental features"
#~ msgstr ""

#~ msgid "tensorcircuit.gates module"
#~ msgstr ""

#~ msgid ""
#~ "declarations of single-qubit and two-"
#~ "qubit gates and their corresponding "
#~ "matrix"
#~ msgstr ""

#~ msgid "Bases: :class:`tensornetwork.network_components.Node`"
#~ msgstr ""

#~ msgid "Wrapper of tn.Node, quantum gate"
#~ msgstr ""

#~ msgid "Bases: :class:`tensorcircuit.gates.GateF`"
#~ msgstr ""

#~ msgid "Note one should provide the gate with properly reshaped."
#~ msgstr ""

#~ msgid "corresponding gate"
#~ msgstr ""

#~ msgid "The name of the gate."
#~ msgstr ""

#~ msgid "the resulted gate"
#~ msgstr ""

#~ msgid "Convert the inputs to Tensor with specified dtype."
#~ msgstr ""

#~ msgid "inputs"
#~ msgstr ""

#~ msgid "dtype of the output Tensors"
#~ msgstr ""

#~ msgid "List of Tensors"
#~ msgstr ""

#~ msgid "Returns a LaTeX bmatrix."
#~ msgstr ""

#~ msgid "Formatted Display:"
#~ msgstr ""

#~ msgid ""
#~ "\\begin{bmatrix}    1.+0.j & 0.+0.j\\\\    "
#~ "0.+0.j & 1.+0.j \\end{bmatrix}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "2D numpy array"
#~ msgstr ""

#~ msgid "ValueError(\"bmatrix can at most display two dimensions\")"
#~ msgstr ""

#~ msgid "latex str for bmatrix of array a"
#~ msgstr ""

#~ msgid ""
#~ "Controlled rotation gate, when the "
#~ "control bit is 1, `rgate` is "
#~ "applied on the target gate."
#~ msgstr ""

#~ msgid "angle in radians"
#~ msgstr ""

#~ msgid "CR Gate"
#~ msgstr ""

#~ msgid ""
#~ "Faster exponential gate, directly implemented"
#~ " based on RHS, only work when: "
#~ ":math:`U^2` is identity matrix."
#~ msgstr ""

#~ msgid ""
#~ "\\rm{exp}(U) &= e^{-i \\theta U} \\\\\n"
#~ "        &= \\cos(\\theta) I - j \\sin(\\theta) U \\\\\n"
#~ "\n"
#~ msgstr ""

#~ msgid "input unitary (U)"
#~ msgstr ""

#~ msgid "suffix of Gate name"
#~ msgstr ""

#~ msgid "Exponential Gate"
#~ msgstr ""

#~ msgid "Exponential gate."
#~ msgstr ""

#~ msgid ""
#~ "\\rm{exp}(U) = e^{-i \\theta U}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "iSwap gate."
#~ msgstr ""

#~ msgid ""
#~ "iSwap(\\theta) =\n"
#~ "\\begin{pmatrix}\n"
#~ "    1 & 0 & 0 & 0\\\\\n"
#~ "    0 & \\cos(\\frac{\\pi}{2} \\theta )"
#~ " & j \\sin(\\frac{\\pi}{2} \\theta ) "
#~ "& 0\\\\\n"
#~ "    0 & j \\sin(\\frac{\\pi}{2} \\theta"
#~ " ) & \\cos(\\frac{\\pi}{2} \\theta ) "
#~ "& 0\\\\\n"
#~ "    0 & 0 & 0 & 1\\\\\n"
#~ "\\end{pmatrix}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "iSwap Gate"
#~ msgstr ""

#~ msgid "Convert Gate to Tensor."
#~ msgstr ""

#~ msgid "input Gate"
#~ msgstr ""

#~ msgid "corresponding Tensor"
#~ msgstr ""

#~ msgid ""
#~ "Inner helper function to generate gate"
#~ " functions, such as ``z()`` from "
#~ "``_z_matrix``"
#~ msgstr ""

#~ msgid "General single qubit rotation gate"
#~ msgstr ""

#~ msgid ""
#~ "R(\\theta, \\phi, \\alpha) = i \\cos(\\theta) I\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "- i \\cos(\\phi) \\sin(\\alpha) \\sin(\\theta) X\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "- i \\sin(\\phi) \\sin(\\alpha) \\sin(\\theta) Y\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "- i \\sin(\\theta) \\cos(\\alpha) Z\n"
#~ "\n"
#~ msgstr ""

#~ msgid "R Gate"
#~ msgstr ""

#~ msgid "Random single qubit gate described in https://arxiv.org/abs/2002.07730."
#~ msgstr ""

#~ msgid "A random single qubit gate"
#~ msgstr ""

#~ msgid "Returns a random two-qubit gate."
#~ msgstr ""

#~ msgid "a random two-qubit gate"
#~ msgstr ""

#~ msgid ""
#~ "Rotation gate, which is in matrix "
#~ "exponential form, shall give the same"
#~ " result as `rgate`."
#~ msgstr ""

#~ msgid ""
#~ "mx = \\sin(\\alpha) \\cos(\\phi) X\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "my = \\sin(\\alpha) \\sin(\\phi) Y\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "mz = \\cos(\\alpha) Z\n"
#~ "\n"
#~ msgstr ""

#~ msgid ""
#~ "R(\\theta, \\alpha, \\phi) = e^{-i\\theta (mx+my+mz)}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "Rotation Gate"
#~ msgstr ""

#~ msgid "Rotation gate along X axis."
#~ msgstr ""

#~ msgid ""
#~ "RX(\\theta) = e^{-i\\frac{\\theta}{2}X}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "RX Gate"
#~ msgstr ""

#~ msgid "Rotation gate along Y axis."
#~ msgstr ""

#~ msgid ""
#~ "RY(\\theta) = e^{-i\\frac{\\theta}{2}Y}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "RY Gate"
#~ msgstr ""

#~ msgid "Rotation gate along Z axis."
#~ msgstr ""

#~ msgid ""
#~ "RZ(\\theta) = e^{-i\\frac{\\theta}{2}Z}\n"
#~ "\n"
#~ msgstr ""

#~ msgid "RZ Gate"
#~ msgstr ""

#~ msgid "tensorcircuit.interfaces module"
#~ msgstr ""

#~ msgid "interfaces bridging different backends"
#~ msgstr ""

#~ msgid "tensorcircuit.keras module"
#~ msgstr ""

#~ msgid "keras layer for tc quantum function"
#~ msgstr ""

#~ msgid "Bases: :class:`keras.engine.base_layer.Layer`"
#~ msgstr ""

#~ msgid ""
#~ "`QuantumLayer` wraps the quantum function "
#~ "`f` as a `keras.Layer` so that "
#~ "tensorcircuit is better integrated with "
#~ "tensorflow."
#~ msgstr ""

#~ msgid "[description], defaults to \"glorot_uniform\""
#~ msgstr ""

#~ msgid ""
#~ "Creates the variables of the layer "
#~ "(optional, for subclass implementers)."
#~ msgstr ""

#~ msgid ""
#~ "This is a method that implementers "
#~ "of subclasses of `Layer` or `Model` "
#~ "can override if they need a "
#~ "state-creation step in-between layer "
#~ "instantiation and layer call."
#~ msgstr ""

#~ msgid "This is typically used to create the weights of `Layer` subclasses."
#~ msgstr ""

#~ msgid "input_shape: Instance of `TensorShape`, or list of instances of"
#~ msgstr ""

#~ msgid ""
#~ "`TensorShape` if the layer expects a "
#~ "list of inputs (one instance per "
#~ "input)."
#~ msgstr ""

#~ msgid ""
#~ "Load function from the files in "
#~ "the ``tf.savedmodel`` format. We can "
#~ "load several functions at the same "
#~ "time, as they can be the same "
#~ "function of different input shapes."
#~ msgstr ""

#~ msgid ""
#~ "The fallback function when all functions"
#~ " loaded are failed, defaults to None"
#~ msgstr ""

#~ msgid ""
#~ "When there is not legal loaded "
#~ "function of the input shape and no"
#~ " fallback callable."
#~ msgstr ""

#~ msgid ""
#~ "A function that tries all loaded "
#~ "function against the input until the "
#~ "first success one."
#~ msgstr ""

#~ msgid ""
#~ "The keras loss function that directly"
#~ " taking the model output as the "
#~ "loss."
#~ msgstr ""

#~ msgid "Save tf function in the file (``tf.savedmodel`` format)."
#~ msgstr ""

#~ msgid "``tf.function`` ed function with graph building"
#~ msgstr ""

#~ msgid "the dir path to save the function"
#~ msgstr ""

#~ msgid "tensorcircuit.mpscircuit module"
#~ msgstr ""

#~ msgid "quantum circuit: MPS state simulator"
#~ msgstr ""

#~ msgid "``MPSCircuit`` class. Simple usage demo below."
#~ msgstr ""

#~ msgid "MPSCircuit object based on state simulator."
#~ msgstr ""

#~ msgid ""
#~ "If not None, the initial state of"
#~ " the circuit is taken as ``tensors``"
#~ " instead of :math:`\\vert 0\\rangle^n` "
#~ "qubits, defaults to None"
#~ msgstr ""

#~ msgid "The center position of MPS, default to 0"
#~ msgstr ""

#~ msgid "Apply a general qubit gate on MPS."
#~ msgstr ""

#~ msgid "The Gate to be applied"
#~ msgstr ""

#~ msgid "Qubit indices of the gate"
#~ msgstr ""

#~ msgid "\"MPS does not support application of gate on > 2 qubits.\""
#~ msgstr ""

#~ msgid ""
#~ "Apply a double qubit gate on "
#~ "adjacent qubits of Matrix Product States"
#~ " (MPS). Truncation rule is specified "
#~ "by `set_truncation_rule`."
#~ msgstr ""

#~ msgid "The first qubit index of the gate"
#~ msgstr ""

#~ msgid "The second qubit index of the gate"
#~ msgstr ""

#~ msgid "Center position of MPS, default is None"
#~ msgstr ""

#~ msgid ""
#~ "Apply a double qubit gate on MPS."
#~ " Truncation rule is specified by "
#~ "`set_truncation_rule`."
#~ msgstr ""

#~ msgid ""
#~ "Apply a single qubit gate on MPS,"
#~ " and the gate must be unitary; "
#~ "no truncation is needed."
#~ msgstr ""

#~ msgid "gate to be applied"
#~ msgstr ""

#~ msgid "Qubit index of the gate"
#~ msgstr ""

#~ msgid "Compute the conjugate of the current MPS."
#~ msgstr ""

#~ msgid "The constructed MPS"
#~ msgstr ""

#~ msgid "Copy the current MPS."
#~ msgstr ""

#~ msgid "Copy the current MPS without the tensors."
#~ msgstr ""

#~ msgid "The contructed MPS"
#~ msgstr ""

#~ msgid "Compute the expectation of the corresponding double qubit gate."
#~ msgstr ""

#~ msgid "qubit index of the gate"
#~ msgstr ""

#~ msgid ""
#~ "Compute the expectation of the "
#~ "corresponding single qubit gate in the"
#~ " form of tensor."
#~ msgstr ""

#~ msgid "Gate to be applied"
#~ msgstr ""

#~ msgid "The expectation of the corresponding single qubit gate"
#~ msgstr ""

#~ msgid ""
#~ "Compute the expectation of the direct"
#~ " product of the corresponding two "
#~ "gates."
#~ msgstr ""

#~ msgid "First gate to be applied"
#~ msgstr ""

#~ msgid "Second gate to be applied"
#~ msgstr ""

#~ msgid "Qubit index of the first gate"
#~ msgstr ""

#~ msgid "Qubit index of the second gate"
#~ msgstr ""

#~ msgid "The correlation of the corresponding two qubit gates"
#~ msgstr ""

#~ msgid "Construct the MPS from a given wavefunction."
#~ msgstr ""

#~ msgid "The given wavefunction (any shape is OK)"
#~ msgstr ""

#~ msgid "The maximum number of singular values to keep."
#~ msgstr ""

#~ msgid "The maximum allowed truncation error."
#~ msgstr ""

#~ msgid "Multiply `max_truncation_err` with the largest singular value."
#~ msgstr ""

#~ msgid ""
#~ "Compute the expectation of corresponding "
#~ "operators in the form of tensor."
#~ msgstr ""

#~ msgid ""
#~ "Operator and its position on the "
#~ "circuit, eg. ``(gates.Z(), [1]), (gates.X(),"
#~ " [2])`` is for operator :math:`Z_1X_2`"
#~ msgstr ""

#~ msgid "The expectation of corresponding operators"
#~ msgstr ""

#~ msgid "Get the normalized Center Position."
#~ msgstr ""

#~ msgid "Normalized Center Position."
#~ msgstr ""

#~ msgid "Check whether the circuit is legal."
#~ msgstr ""

#~ msgid "Whether the circuit is legal."
#~ msgstr ""

#~ msgid "integer indicating the measure on which quantum line"
#~ msgstr ""

#~ msgid ""
#~ "Middle measurement in the z-basis on "
#~ "the circuit, note the wavefunction "
#~ "output is not normalized with "
#~ "``mid_measurement`` involved, one should "
#~ "normalized the state manually if needed."
#~ msgstr ""

#~ msgid "The index of qubit that the Z direction postselection applied on"
#~ msgstr ""

#~ msgid "0 for spin up, 1 for spin down, defaults to 0"
#~ msgstr ""

#~ msgid "Normalize MPS Circuit according to the center position."
#~ msgstr ""

#~ msgid "Wrapper of tn.FiniteMPS.position. Set orthogonality center."
#~ msgstr ""

#~ msgid "The orthogonality center"
#~ msgstr ""

#~ msgid "Compute the projection between `other` as bra and `self` as ket."
#~ msgstr ""

#~ msgid "ket of the other MPS, which will be converted to bra automatically"
#~ msgstr ""

#~ msgid "The projection in form of tensor"
#~ msgstr ""

#~ msgid ""
#~ "Set truncation rules when double qubit"
#~ " gates are applied. If nothing is "
#~ "specified, no truncation will take place"
#~ " and the bond dimension will keep "
#~ "growing. For more details, refer to "
#~ "`split_tensor`."
#~ msgstr ""

#~ msgid "Tensor with shape [1, -1]"
#~ msgstr ""

#~ msgid ""
#~ "Split the tensor by SVD or QR "
#~ "depends on whether a truncation is "
#~ "required."
#~ msgstr ""

#~ msgid "The input tensor to split."
#~ msgstr ""

#~ msgid ""
#~ "Determine the orthogonal center is on"
#~ " the left tensor or the right "
#~ "tensor."
#~ msgstr ""

#~ msgid "Two tensors after splitting"
#~ msgstr ""

#~ msgid "tensorcircuit.quantum module"
#~ msgstr ""

#~ msgid "quantum state and operator class backend by tensornetwork"
#~ msgstr ""

#~ msgid "Bases: :class:`tensorcircuit.quantum.QuOperator`"
#~ msgstr ""

#~ msgid "Represents an adjoint (row) vector via a tensor network."
#~ msgstr ""

#~ msgid ""
#~ "Constructs a new `QuAdjointVector` from "
#~ "a tensor network. This encapsulates an"
#~ " existing tensor network, interpreting it"
#~ " as an adjoint vector (row vector)."
#~ msgstr ""

#~ msgid "The edges of the network to be used as the input edges."
#~ msgstr ""

#~ msgid ""
#~ "Nodes used to refer to parts of"
#~ " the tensor network that are not "
#~ "connected to any input or output "
#~ "edges (for example: a scalar factor)."
#~ msgstr ""

#~ msgid ""
#~ "Optional collection of edges to ignore"
#~ " when performing consistency checks."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuAdjointVector` directly from"
#~ " a single tensor. This first wraps"
#~ " the tensor in a `Node`, then "
#~ "constructs the `QuAdjointVector` from that "
#~ "`Node`."
#~ msgstr ""

#~ msgid "The tensor for consturcting an QuAdjointVector."
#~ msgstr ""

#~ msgid ""
#~ "Sequence of integer indices specifying "
#~ "the order in which to interpret "
#~ "the axes as subsystems (input edges)."
#~ " If not specified, the axes are "
#~ "taken in ascending order."
#~ msgstr ""

#~ msgid "The new construted QuAdjointVector give from the given tensor."
#~ msgstr ""

#~ msgid ""
#~ "Represents a linear operator via a "
#~ "tensor network. To interpret a tensor"
#~ " network as a linear operator, some"
#~ " of the dangling edges must be "
#~ "designated as `out_edges` (output edges) "
#~ "and the rest as `in_edges` (input "
#~ "edges). Considered as a matrix, the "
#~ "`out_edges` represent the row index and"
#~ " the `in_edges` represent the column "
#~ "index. The (right) action of the "
#~ "operator on another then consists of "
#~ "connecting the `in_edges` of the first"
#~ " operator to the `out_edges` of the"
#~ " second. Can be used to do "
#~ "simple linear algebra with tensor "
#~ "networks."
#~ msgstr ""

#~ msgid ""
#~ "Creates a new `QuOperator` from a "
#~ "tensor network. This encapsulates an "
#~ "existing tensor network, interpreting it "
#~ "as a linear operator. The network "
#~ "is checked for consistency: All dangling"
#~ " edges must either be in `out_edges`,"
#~ " `in_edges`, or `ignore_edges`."
#~ msgstr ""

#~ msgid "The edges of the network to be used as the output edges."
#~ msgstr ""

#~ msgid ""
#~ "Optional collection of dangling edges to"
#~ " ignore when performing consistency checks."
#~ msgstr ""

#~ msgid ""
#~ "At least one reference node is "
#~ "required to specify a scalar. None "
#~ "provided!"
#~ msgstr ""

#~ msgid ""
#~ "The adjoint of the operator. This "
#~ "creates a new `QuOperator` with "
#~ "complex-conjugate copies of all tensors "
#~ "in the network and with the input"
#~ " and output edges switched."
#~ msgstr ""

#~ msgid ""
#~ "Check that the network has the "
#~ "expected dimensionality. This checks that "
#~ "all input and output edges are "
#~ "dangling and that there are no "
#~ "other dangling edges (except any "
#~ "specified in `ignore_edges`). If not, an"
#~ " exception is raised."
#~ msgstr ""

#~ msgid ""
#~ "Contract the tensor network in place."
#~ " This modifies the tensor network "
#~ "representation of the operator (or "
#~ "vector, or scalar), reducing it to "
#~ "a single tensor, without changing the"
#~ " value."
#~ msgstr ""

#~ msgid "Manually specify the axis ordering of the final tensor."
#~ msgstr ""

#~ msgid "The present object."
#~ msgstr ""

#~ msgid ""
#~ "Contracts the tensor network in place"
#~ " and returns the final tensor. Note"
#~ " that this modifies the tensor "
#~ "network representing the operator. The "
#~ "default ordering for the axes of "
#~ "the final tensor is:"
#~ msgstr ""

#~ msgid "`*out_edges, *in_edges`."
#~ msgstr ""

#~ msgid "If there are any \"ignored\" edges, their axes come first:"
#~ msgstr ""

#~ msgid "`*ignored_edges, *out_edges, *in_edges`."
#~ msgstr ""

#~ msgid ""
#~ "Manually specify the axis ordering of"
#~ " the final tensor. The default "
#~ "ordering is determined by `out_edges` "
#~ "and `in_edges` (see above)."
#~ msgstr ""

#~ msgid "Node count '{}' > 1 after contraction!"
#~ msgstr ""

#~ msgid "The final tensor representing the operator."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuOperator` directly from a"
#~ " single tensor. This first wraps the"
#~ " tensor in a `Node`, then constructs"
#~ " the `QuOperator` from that `Node`."
#~ msgstr ""

#~ msgid "The tensor."
#~ msgstr ""

#~ msgid "The axis indices of `tensor` to use as `out_edges`."
#~ msgstr ""

#~ msgid "The axis indices of `tensor` to use as `in_edges`."
#~ msgstr ""

#~ msgid "The new operator."
#~ msgstr ""

#~ msgid "All tensor-network nodes involved in the operator."
#~ msgstr ""

#~ msgid ""
#~ "The norm of the operator. This is"
#~ " the 2-norm (also known as the "
#~ "Frobenius or Hilbert-Schmidt norm)."
#~ msgstr ""

#~ msgid ""
#~ "The partial trace of the operator. "
#~ "Subsystems to trace out are supplied "
#~ "as indices, so that dangling edges "
#~ "are connected to each other as:"
#~ msgstr ""

#~ msgid "`out_edges[i] ^ in_edges[i] for i in subsystems_to_trace_out`"
#~ msgstr ""

#~ msgid ""
#~ "This does not modify the original "
#~ "network. The original ordering of the"
#~ " remaining subsystems is maintained."
#~ msgstr ""

#~ msgid "Indices of subsystems to trace out."
#~ msgstr ""

#~ msgid "A new QuOperator or QuScalar representing the result."
#~ msgstr ""

#~ msgid ""
#~ "Tensor product with another operator. "
#~ "Given two operators `A` and `B`, "
#~ "produces a new operator `AB` "
#~ "representing `A` ⊗ `B`. The `out_edges`"
#~ " (`in_edges`) of `AB` is simply the"
#~ " concatenation of the `out_edges` "
#~ "(`in_edges`) of `A.copy()` with that of"
#~ " `B.copy()`: `new_out_edges = [*out_edges_A_copy,"
#~ " *out_edges_B_copy]` `new_in_edges = "
#~ "[*in_edges_A_copy, *in_edges_B_copy]`"
#~ msgstr ""

#~ msgid "The other operator (`B`)."
#~ msgstr ""

#~ msgid "The result (`AB`)."
#~ msgstr ""

#~ msgid "The trace of the operator."
#~ msgstr ""

#~ msgid "Represents a scalar via a tensor network."
#~ msgstr ""

#~ msgid ""
#~ "Constructs a new `QuScalar` from a "
#~ "tensor network. This encapsulates an "
#~ "existing tensor network, interpreting it "
#~ "as a scalar."
#~ msgstr ""

#~ msgid ""
#~ "Nodes used to refer to the tensor"
#~ " network (need not be exhaustive -"
#~ " one node from each disconnected "
#~ "subnetwork is sufficient)."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuScalar` directly from a"
#~ " single tensor. This first wraps the"
#~ " tensor in a `Node`, then constructs"
#~ " the `QuScalar` from that `Node`."
#~ msgstr ""

#~ msgid "The tensor for constructing a new QuScalar."
#~ msgstr ""

#~ msgid "The new constructed QuScalar from the given tensor."
#~ msgstr ""

#~ msgid "Represents a (column) vector via a tensor network."
#~ msgstr ""

#~ msgid ""
#~ "Constructs a new `QuVector` from a "
#~ "tensor network. This encapsulates an "
#~ "existing tensor network, interpreting it "
#~ "as a (column) vector."
#~ msgstr ""

#~ msgid ""
#~ "Construct a `QuVector` directly from a"
#~ " single tensor. This first wraps the"
#~ " tensor in a `Node`, then constructs"
#~ " the `QuVector` from that `Node`."
#~ msgstr ""

#~ msgid "The tensor for constructing a \"QuVector\"."
#~ msgstr ""

#~ msgid ""
#~ "Sequence of integer indices specifying "
#~ "the order in which to interpret "
#~ "the axes as subsystems (output edges)."
#~ " If not specified, the axes are "
#~ "taken in ascending order."
#~ msgstr ""

#~ msgid "The new constructed QuVector from the given tensor."
#~ msgstr ""

#~ msgid ""
#~ "Check the vector spaces represented by"
#~ " two lists of edges are compatible."
#~ " The number of edges must be "
#~ "the same and the dimensions of "
#~ "each pair of edges must match. "
#~ "Otherwise, an exception is raised. "
#~ ":param edges_1: List of edges "
#~ "representing a many-body Hilbert space."
#~ " :type edges_1: Sequence[Edge] :param "
#~ "edges_2: List of edges representing a"
#~ " many-body Hilbert space. :type "
#~ "edges_2: Sequence[Edge]"
#~ msgstr ""

#~ msgid ""
#~ "Hilbert-space mismatch: \"Cannot connect "
#~ "{} subsystems with {} subsystems\", or"
#~ " \"Input dimension {} != output "
#~ "dimension {}.\""
#~ msgstr ""

#~ msgid ""
#~ "Eliminates any connected CopyNodes that "
#~ "are identity matrices. This will modify"
#~ " the network represented by `nodes`. "
#~ "Only identities that are connected to"
#~ " other nodes are eliminated."
#~ msgstr ""

#~ msgid "Collection of nodes to search."
#~ msgstr ""

#~ msgid ""
#~ "The Dictionary mapping remaining Nodes "
#~ "to any replacements, Dictionary specifying "
#~ "all dangling-edge replacements."
#~ msgstr ""

#~ msgid "Compute the entropy from the given density matrix ``rho``."
#~ msgstr ""

#~ msgid "[description], defaults to 1e-12"
#~ msgstr ""

#~ msgid ""
#~ "Note: further jit is recommended, for"
#~ " large Hilbert space, sparse Hamiltonian"
#~ " is recommended"
#~ msgstr ""

#~ msgid ""
#~ "Construct a 'QuOperator' representing the "
#~ "identity on a given space. Internally,"
#~ " this is done by constructing "
#~ "'CopyNode's for each edge, with "
#~ "dimension according to 'space'."
#~ msgstr ""

#~ msgid ""
#~ "A sequence of integers for the "
#~ "dimensions of the tensor product factors"
#~ " of the space (the edges in the"
#~ " tensor network)."
#~ msgstr ""

#~ msgid "The data type (for conversion to dense)."
#~ msgstr ""

#~ msgid "The desired identity operator."
#~ msgstr ""

#~ msgid ""
#~ "Simulate the measuring of each qubit "
#~ "of ``p`` in the computational basis, "
#~ "thus producing output like that of "
#~ "``qiskit``."
#~ msgstr ""

#~ msgid ""
#~ "The quantum state, assumed to be "
#~ "normalized, as either a ket or "
#~ "density operator."
#~ msgstr ""

#~ msgid "The number of counts to perform."
#~ msgstr ""

#~ msgid ""
#~ "Defaults True. The bool indicating "
#~ "whether the return form is in the"
#~ " form of two array or one of"
#~ " the same length as the ``state`` "
#~ "(if ``sparse=False``)."
#~ msgstr ""

#~ msgid "The counts for each bit string measured."
#~ msgstr ""

#~ msgid ""
#~ "Constructs an appropriately specialized "
#~ "QuOperator. If there are no edges, "
#~ "creates a QuScalar. If the are "
#~ "only output (input) edges, creates a "
#~ "QuVector (QuAdjointVector). Otherwise creates "
#~ "a QuOperator."
#~ msgstr ""

#~ msgid "output edges."
#~ msgstr ""

#~ msgid "in edges."
#~ msgstr ""

#~ msgid ""
#~ "reference nodes for the tensor network"
#~ " (needed if there is a scalar "
#~ "component)."
#~ msgstr ""

#~ msgid "edges to ignore when checking the dimensionality of the tensor network."
#~ msgstr ""

#~ msgid "The new created QuOperator object."
#~ msgstr ""

#~ msgid "Compute the reduced density matrix from quantum state ``state``."
#~ msgstr ""

#~ msgid "Compute the trace of several inputs ``o`` as tensor or ``QuOperator``."
#~ msgstr ""

#~ msgid "\\mathrm{Tr}(\\prod_i O_i)"
#~ msgstr ""

#~ msgid "a scalar"
#~ msgstr ""

#~ msgid "tensorcircuit.simplify module"
#~ msgstr ""

#~ msgid "tensornetwork simplification"
#~ msgstr ""

#~ msgid ""
#~ "Get the new shape of two nodes,"
#~ " also supporting to return original "
#~ "shapes of two nodes."
#~ msgstr ""

#~ msgid "node one"
#~ msgstr ""

#~ msgid "node two"
#~ msgstr ""

#~ msgid "Whether to include original shape of two nodes, default is True."
#~ msgstr ""

#~ msgid "The new shape of the two nodes."
#~ msgstr ""

#~ msgid ""
#~ "Contract between Node ``a`` and ``b``,"
#~ " with correct shape only and no "
#~ "calculation"
#~ msgstr ""

#~ msgid "tensorcircuit.templates module"
#~ msgstr ""

#~ msgid "tensorcircuit.templates.blocks module"
#~ msgstr ""

#~ msgid "shortcuts for measurement patterns on circuit"
#~ msgstr ""

#~ msgid "tensorcircuit.templates.graphs module"
#~ msgstr ""

#~ msgid "Some common graphs and lattices"
#~ msgstr ""

#~ msgid "1D chain with ``n`` sites"
#~ msgstr ""

#~ msgid "tensorcircuit.templates.measurements module"
#~ msgstr ""

#~ msgid ""
#~ "This measurements pattern is specifically "
#~ "suitable for vmap. Parameterize the "
#~ "Pauli string to be measured."
#~ msgstr ""

#~ msgid ""
#~ "parameter tensors determines what Pauli "
#~ "string to be measured, shape is "
#~ "[nwires, 4] if onehot is False."
#~ msgstr ""

#~ msgid ""
#~ "[description], defaults to False. If set"
#~ " to be True, structures will first"
#~ " go through onehot procedure."
#~ msgstr ""

#~ msgid "COO_sparse_matrix"
#~ msgstr ""

#~ msgid "a real and scalar tensor of shape []"
#~ msgstr ""

#~ msgid "tensorcircuit.utils module"
#~ msgstr ""

#~ msgid "some helper functions"
#~ msgstr ""

#~ msgid ""
#~ "Return a callable function for output"
#~ " ith parts of the original output "
#~ "along the first axis. Original output"
#~ " supports List and Tensor."
#~ msgstr ""

#~ msgid "The function to be applied this method"
#~ msgstr ""

#~ msgid "The ith parts of original output along the first axis (axis=0 or dim=0)"
#~ msgstr ""

#~ msgid "The modified callable function"
#~ msgstr ""

#~ msgid "tensorcircuit.vis module"
#~ msgstr ""

#~ msgid "visualization on circuits"
#~ msgstr ""

#~ msgid "# TODO(@YHPeter): add examples"
#~ msgstr ""

#~ msgid ""
#~ "Generate the PDF file with given "
#~ "latex string and filename. Latex command"
#~ " and file path can be specified. "
#~ "When notebook is True, convert the "
#~ "output PDF file to image and "
#~ "return a Image object."
#~ msgstr ""

#~ msgid "String of latex content"
#~ msgstr ""

#~ msgid "File name, defaults to random UUID `str(uuid4())`"
#~ msgstr ""

#~ msgid "Executable Latex command, defaults to `pdflatex`"
#~ msgstr ""

#~ msgid "File path, defaults to current working place `os.getcwd()`"
#~ msgstr ""

#~ msgid "if notebook is True, return `Image` object; otherwise return `None`"
#~ msgstr ""

#~ msgid "tensorcircuit"
#~ msgstr ""

#~ msgid "TensorCircuit"
#~ msgstr ""

